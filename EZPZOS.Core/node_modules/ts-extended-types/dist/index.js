"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asUuid = exports.isUuid = exports.isLocalTime = exports.createLocalTime = exports.isLocalDate = exports.createLocalDate = exports.isLocalDateTime = exports.createLocalDateTime = exports.ceilToStringInt = exports.floorToStringInt = exports.truncateToStringInt = exports.roundToStringInt = exports.asStringInt = exports.isStringInt = exports.ceilToInt = exports.floorToInt = exports.truncateToInt = exports.roundToInt = exports.asInt = exports.isInt = exports.asStringDouble = exports.isStringDouble = exports.asDouble = exports.isDouble = void 0;
/**
 * Returns `true` if the value is a `double` number, otherwise returns `false`
 *
 * @param value Value to verify if it is a `double`
 */
function isDouble(value) {
    return typeof value === 'number';
}
exports.isDouble = isDouble;
/**
 * Cast the number provided by argument as `double`
 *
 * @param value Number to be casted to `double`
 */
function asDouble(value) {
    return value;
}
exports.asDouble = asDouble;
/**
 * Returns `true` if the value is a `stringDouble` number, otherwise returns `false`
 *
 * @param value Value to verify if it is a `stringDouble`
 */
function isStringDouble(value) {
    return typeof value === 'number' || (typeof value === 'string' && /^-?\d+(\.\d+)?$/g.test(value));
}
exports.isStringDouble = isStringDouble;
/**
 * Cast the number provided by argument as `stringDouble`, throws an error if the provided number is not a double
 *
 * @param value Number to be casted to `stringDouble`
 */
function asStringDouble(value) {
    if (isStringDouble(value)) {
        return value;
    }
    else {
        throw new Error('Invalid stringDouble number: ' + value);
    }
}
exports.asStringDouble = asStringDouble;
/**
 * Returns `true` if the value is a `int` number, otherwise returns `false`
 *
 * @param value Value to verify if it is a `int`
 */
function isInt(value) {
    return Number.isInteger(value);
}
exports.isInt = isInt;
/**
 * Cast the number provided by argument as `int`, throws an error if the provided number is not an integer
 *
 * @param value Number to be casted to `int`
 */
function asInt(value) {
    if (Number.isInteger(value)) {
        return value;
    }
    else {
        throw new Error('Invalid int number: ' + value);
    }
}
exports.asInt = asInt;
/**
 * Round the provided number to an integer and then cast it to `int`
 *
 * @param value Number to be rounded and casted to `int`
 */
function roundToInt(value) {
    return Math.round(value);
}
exports.roundToInt = roundToInt;
/**
 * Truncate the provided number to an integer and then cast it to `int`
 *
 * @param value Number to be truncated and casted to `int`
 */
function truncateToInt(value) {
    return Math.trunc(value);
}
exports.truncateToInt = truncateToInt;
/**
 * Floor the provided number to an integer and then cast it to `int`
 *
 * @param value Number to be floored and casted to `int`
 */
function floorToInt(value) {
    return Math.floor(value);
}
exports.floorToInt = floorToInt;
/**
 * Ceil the provided number to an integer and then cast it to `int`
 *
 * @param value Number to be ceiled and casted to `int`
 */
function ceilToInt(value) {
    return Math.ceil(value);
}
exports.ceilToInt = ceilToInt;
/**
 * Returns `true` if the value is a `stringInt` number, otherwise returns `false`
 *
 * @param value Value to verify if it is a `stringInt`
 */
function isStringInt(value) {
    return Number.isInteger(value) || (typeof value === 'string' && /^-?\d+$/g.test(value));
}
exports.isStringInt = isStringInt;
/**
 * Cast the number provided by argument as `stringInt`, throws an error if the provided number is not an integer
 *
 * @param value Number to be casted to `stringInt`
 */
function asStringInt(value) {
    if (isStringInt(value)) {
        return value;
    }
    else {
        throw new Error('Invalid stringInt number: ' + value);
    }
}
exports.asStringInt = asStringInt;
/**
 * Round the provided number to an integer and then cast it to `stringInt`
 *
 * @param value Number to be rounded and casted to `stringInt`
 */
function roundToStringInt(value) {
    return Math.round(value);
}
exports.roundToStringInt = roundToStringInt;
/**
 * Truncate the provided number to an integer and then cast it to `stringInt`
 *
 * @param value Number to be truncated and casted to `stringInt`
 */
function truncateToStringInt(value) {
    return Math.trunc(value);
}
exports.truncateToStringInt = truncateToStringInt;
/**
 * Floor the provided number to an integer and then cast it to `stringInt`
 *
 * @param value Number to be floored and casted to `stringInt`
 */
function floorToStringInt(value) {
    return Math.floor(value);
}
exports.floorToStringInt = floorToStringInt;
/**
 * Ceil the provided number to an integer and then cast it to `stringInt`
 *
 * @param value Number to be ceiled and casted to `stringInt`
 */
function ceilToStringInt(value) {
    return Math.ceil(value);
}
exports.ceilToStringInt = ceilToStringInt;
function createLocalDateTime(year, month = 0, date = 1, hours = 0, minutes = 0, seconds = 0, milliseconds = 0) {
    let result;
    if (year === null || year === undefined) {
        result = new Date();
    }
    else if (year instanceof Date) {
        if (year.___type___ === 'LocalDateTime') {
            result = year;
        }
        else {
            result = new Date(year.getTime());
        }
    }
    else {
        result = new Date(year, month, date, hours, minutes, seconds, milliseconds);
    }
    if (isNaN(result.getTime())) {
        throw new Error('Ivalid LocalDateTime');
    }
    result.___type___ = 'LocalDateTime';
    return result;
}
exports.createLocalDateTime = createLocalDateTime;
/**
 * Returns `true` if the value is a `LocalDateTime`, otherwise returns `false`
 *
 * @param value Value to verify if it is a `LocalDateTime`
 */
function isLocalDateTime(value) {
    return value instanceof Date && value.___type___ === 'LocalDateTime';
}
exports.isLocalDateTime = isLocalDateTime;
function createLocalDate(year, month = 0, date = 1) {
    let result;
    if (year === null || year === undefined) {
        result = new Date();
        // This time fix works in almost every timezone (from -10 to +13, but not +14, -11, -12, almost uninhabited)
        result = new Date(Date.UTC(result.getFullYear(), result.getMonth(), result.getDate()));
        result.setUTCMinutes(600);
    }
    else if (year instanceof Date) {
        if (year.___type___ === 'LocalDate') {
            result = year;
        }
        else {
            // This time fix works in almost every timezone (from -10 to +13, but not +14, -11, -12, almost uninhabited)
            result = new Date(Date.UTC(year.getFullYear(), year.getMonth(), year.getDate()));
            result.setUTCMinutes(600);
        }
    }
    else {
        // This solution can create problems with diferents timezones
        //result = new Date(year, month, day, 0, 0, 0, 0)
        // This time fix works in almost every timezone (from -10 to +13, but not +14, -11, -12, almost uninhabited)
        result = new Date(Date.UTC(year, month, date));
        result.setUTCMinutes(600);
    }
    if (isNaN(result.getTime())) {
        throw new Error('Ivalid LocalDate');
    }
    result.___type___ = 'LocalDate';
    return result;
}
exports.createLocalDate = createLocalDate;
/**
 * Returns `true` if the value is a `LocalDate`, otherwise returns `false`
 *
 * @param value Value to verify if it is a `LocalDate`
 */
function isLocalDate(value) {
    return value instanceof Date && value.___type___ === 'LocalDate';
}
exports.isLocalDate = isLocalDate;
function createLocalTime(hours, minutes = 0, seconds = 0, milliseconds = 0) {
    let result;
    if (hours === null || hours === undefined) {
        result = new Date();
    }
    else if (hours instanceof Date) {
        if (hours.___type___ === 'LocalTime') {
            result = hours;
        }
        else {
            result = new Date(1970, 0, 1, hours.getHours(), hours.getMinutes(), hours.getSeconds(), hours.getMilliseconds());
        }
    }
    else {
        result = new Date(1970, 0, 1, hours, minutes, seconds, milliseconds);
    }
    if (isNaN(result.getTime())) {
        throw new Error('Ivalid LocalTime');
    }
    result.___type___ = 'LocalTime';
    return result;
}
exports.createLocalTime = createLocalTime;
/**
 * Returns `true` if the value is a `LocalTime`, otherwise returns `false`
 *
 * @param value Value to verify if it is a `LocalTime`
 */
function isLocalTime(value) {
    return value instanceof Date && value.___type___ === 'LocalTime';
}
exports.isLocalTime = isLocalTime;
const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
/**
 * Returns `true` if the value is a `uuid` string, otherwise returns `false`
 *
 * @param value Value to verify if it is a `uuid`
 */
function isUuid(value) {
    return typeof value === 'string' && uuidRegex.test(value);
}
exports.isUuid = isUuid;
/**
 * Cast the string provided by argument as `uuid`, throws an error if the provided string is not a uuid
 *
 * @param value String to be casted to `uuid`
 */
function asUuid(value) {
    if (isUuid(value)) {
        return value;
    }
    else {
        throw new Error('Invalid uuid: ' + value);
    }
}
exports.asUuid = asUuid;
//# sourceMappingURL=index.js.map