"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractSqlBuilder = void 0;
const SqlBuilder_1 = require("./SqlBuilder");
const ITableOrView_1 = require("../utils/ITableOrView");
const values_1 = require("../expressions/values");
const Column_1 = require("../utils/Column");
const TypeAdapter_1 = require("../TypeAdapter");
const ValueSourceImpl_1 = require("../internal/ValueSourceImpl");
const SqlBuilder_2 = require("./SqlBuilder");
const ITableOrView_2 = require("../utils/ITableOrView");
const Column_2 = require("../utils/Column");
const SqlBuilder_3 = require("./SqlBuilder");
const values_2 = require("../expressions/values");
class AbstractSqlBuilder {
    constructor() {
        this._unique = 1;
        this._supportTableAliasWithAs = true;
        this._insertSupportWith = true;
        this._updateNewAlias = '_new_';
        this._updateOldValueInFrom = true;
        this._trueValue = 'true';
        this._trueValueForCondition = 'true';
        this._falseValue = 'false';
        this._falseValueForCondition = 'false';
        this._supportOrderByWhenAggregateArray = false;
        this._supportLimitWhenAggregateArray = false;
        this._operationsThatNeedParenthesis = {
            _equals: true,
            _notEquals: true,
            _is: true,
            _isNot: true,
            _equalsInsensitive: true,
            _notEqualsInsensitive: true,
            _lessThan: true,
            _greaterThan: true,
            _lessOrEquals: true,
            _greaterOrEquals: true,
            _and: true,
            _or: true,
            _concat: true,
            _add: true,
            _substract: true,
            _multiply: true,
            _divide: true,
            _modulo: true,
            _fragment: true
        };
    }
    _generateUnique() {
        return this._unique++;
    }
    _resetUnique() {
        this._unique = 1;
    }
    _getSafeTableOrView(params) {
        return params._safeTableOrView;
    }
    _setSafeTableOrView(params, tableOrView) {
        Object.defineProperty(params, '_safeTableOrView', {
            value: tableOrView,
            writable: true,
            enumerable: false,
            configurable: true
        });
    }
    _getForceAliasAs(params) {
        return params._forceAliasAs;
    }
    _setForceAliasAs(params, value) {
        Object.defineProperty(params, '_forceAliasAs', {
            value: value,
            writable: true,
            enumerable: false,
            configurable: true
        });
    }
    _getForceAliasFor(params) {
        return params._forceAliasFor;
    }
    _setForceAliasFor(params, value) {
        Object.defineProperty(params, '_forceAliasFor', {
            value: value,
            writable: true,
            enumerable: false,
            configurable: true
        });
    }
    _getFakeNamesOf(params) {
        return params._fakeNamesOf;
    }
    _setFakeNamesOf(params, value) {
        Object.defineProperty(params, '_fakeNamesOf', {
            value: value,
            writable: true,
            enumerable: false,
            configurable: true
        });
    }
    _generateExternalWith(params) {
        return !!params._generateExternalWith;
    }
    _setGenerateExternalWith(params, value) {
        Object.defineProperty(params, '_generateExternalWith', {
            value: value,
            writable: true,
            enumerable: false,
            configurable: true
        });
    }
    _isWithGenerated(params) {
        return !!params._withGenerated;
    }
    _setWithGenerated(params, value) {
        Object.defineProperty(params, '_withGenerated', {
            value: value,
            writable: true,
            enumerable: false,
            configurable: true
        });
    }
    _isWithGeneratedFinished(params) {
        return !!params._withGeneratedFinished;
    }
    _setWithGeneratedFinished(params, value) {
        Object.defineProperty(params, '_withGeneratedFinished', {
            value: value,
            writable: true,
            enumerable: false,
            configurable: true
        });
    }
    _isAggregateArrayWrapped(params) {
        return !!params._isAggregateArrayWrapped;
    }
    _setAggregateArrayWrapped(params, value) {
        Object.defineProperty(params, '_isAggregateArrayWrapped', {
            value: value,
            writable: true,
            enumerable: false,
            configurable: true
        });
    }
    _getResultingOperation(params) {
        return params._resultingOperation;
    }
    _setResultingOperation(params, value) {
        Object.defineProperty(params, '_resultingOperation', {
            value: value,
            writable: true,
            enumerable: false,
            configurable: true
        });
    }
    // Read in the query runner
    _getContainsInsertReturningClause(params) {
        return params._containsInsertReturningClause;
    }
    _setContainsInsertReturningClause(params, value) {
        Object.defineProperty(params, '_containsInsertReturningClause', {
            value: value,
            writable: true,
            enumerable: false,
            configurable: true
        });
    }
    _ensureRootQuery(query, params) {
        const rootQuery = params._rootQuery;
        if (!rootQuery) {
            Object.defineProperty(params, '_rootQuery', {
                value: query,
                writable: true,
                enumerable: false,
                configurable: true
            });
        }
    }
    _isCurrentRootQuery(query, params) {
        const rootQuery = params._rootQuery;
        return rootQuery === query;
    }
    _resetRootQuery(query, params) {
        const rootQuery = params._rootQuery;
        if (rootQuery === query) {
            Object.defineProperty(params, '_rootQuery', {
                value: undefined,
                writable: true,
                enumerable: false,
                configurable: true
            });
        }
    }
    _getRootQuery(params) {
        return params._containsInsertReturningClause;
    }
    _setRootQuery(params, value) {
        Object.defineProperty(params, '_rootQuery', {
            value: value,
            writable: true,
            enumerable: false,
            configurable: true
        });
    }
    _isValue(value) {
        if (value === null || value === undefined) {
            return false;
        }
        if (!this._connectionConfiguration.allowEmptyString && value === '') {
            return false;
        }
        if (Array.isArray(value) && value.length <= 0) {
            return false;
        }
        return true;
    }
    _isReservedKeyword(_word) {
        return false;
    }
    _forceAsIdentifier(identifier) {
        return '"' + identifier + '"';
    }
    _escape(identifier, strict) {
        return this._connectionConfiguration.escape(identifier, strict);
    }
    _needParenthesis(value) {
        const operation = (0, SqlBuilder_2.operationOf)(value);
        if (!operation) {
            return false;
        }
        if (this._operationsThatNeedParenthesis[operation]) {
            return true;
        }
        return false;
    }
    _needParenthesisExcluding(value, excluding) {
        const operation = (0, SqlBuilder_2.operationOf)(value);
        if (!operation) {
            return false;
        }
        if (operation === excluding) {
            return false;
        }
        if (this._operationsThatNeedParenthesis[operation]) {
            return true;
        }
        return false;
    }
    _appendColumnName(column, params) {
        const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
        const typeAdapter = columnPrivate.__typeAdapter;
        if ((0, values_1.__isBooleanValueSource)(columnPrivate) && typeAdapter instanceof TypeAdapter_1.CustomBooleanTypeAdapter) {
            return '(' + this._appendRawColumnName(column, params) + ' = ' + this._appendLiteralValue(typeAdapter.trueValue, params) + ')';
        }
        return this._appendRawColumnName(column, params);
    }
    _appendColumnNameForCondition(column, params) {
        const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
        const typeAdapter = columnPrivate.__typeAdapter;
        if ((0, values_1.__isBooleanValueSource)(columnPrivate) && typeAdapter instanceof TypeAdapter_1.CustomBooleanTypeAdapter) {
            return this._appendRawColumnName(column, params) + ' = ' + this._appendLiteralValue(typeAdapter.trueValue, params);
        }
        return this._appendRawColumnName(column, params);
    }
    _appendRawColumnName(column, params) {
        const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
        const tableOrView = columnPrivate.__tableOrView;
        const tablePrivate = (0, ITableOrView_2.__getTableOrViewPrivate)(tableOrView);
        const forceAliasFor = this._getForceAliasFor(params);
        const forceAliasAs = this._getForceAliasAs(params);
        const fakeNamesOf = this._getFakeNamesOf(params);
        if (tablePrivate.__valuesForInsert) {
            return this._appendRawColumnNameForValuesForInsert(column, params);
        }
        if (forceAliasFor === tableOrView && forceAliasAs) {
            return this._escape(forceAliasAs, true) + '.' + this._escape(columnPrivate.__name, true);
        }
        if (fakeNamesOf && fakeNamesOf.has(tableOrView)) {
            if (tablePrivate.__as) {
                return this._escape('_old_', true) + '.' + this._escape(tablePrivate.__as + '__' + columnPrivate.__name, true);
            }
            else {
                return this._escape('_old_', true) + '.' + this._escape(tablePrivate.__name + '__' + columnPrivate.__name, true);
            }
        }
        if (tablePrivate.__as) {
            return this._escape(tablePrivate.__as, true) + '.' + this._escape(columnPrivate.__name, true);
        }
        else if (this._getSafeTableOrView(params) === tableOrView) {
            return this._escape(columnPrivate.__name, true);
        }
        else {
            return this._escape(tablePrivate.__name, false) + '.' + this._escape(columnPrivate.__name, true);
        }
    }
    _appendRawColumnNameForValuesForInsert(column, _params) {
        const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
        return 'excluded.' + this._escape(columnPrivate.__name, true);
    }
    _appendLiteralValue(value, _params) {
        if (typeof value === 'number') {
            return '' + value;
        }
        else {
            return "'" + value + "'";
        }
    }
    _getTableOrViewVisibleName(table) {
        const t = (0, ITableOrView_2.__getTableOrViewPrivate)(table);
        let result = this._escape(t.__name, false);
        if (t.__as) {
            result += ' as ' + this._escape(t.__as, true);
        }
        if (t.__customizationName) {
            result += ' (customization name: ' + t.__customizationName + ')';
        }
        return result;
    }
    _appendTableOrViewName(table, params) {
        const t = (0, ITableOrView_2.__getTableOrViewPrivate)(table);
        if (t.__template) {
            return this._appendRawFragment(t.__template, params);
        }
        const forceAliasFor = this._getForceAliasFor(params);
        const forceAliasAs = this._getForceAliasAs(params);
        let result = this._appendTableOrViewNameForFrom(table, params);
        if (forceAliasFor === table && forceAliasAs) {
            if (this._supportTableAliasWithAs) {
                result += ' as ';
            }
            else {
                result += ' ';
            }
            result += this._escape(forceAliasAs, true);
        }
        else if (t.__as) {
            if (this._supportTableAliasWithAs) {
                result += ' as ';
            }
            else {
                result += ' ';
            }
            result += this._escape(t.__as, true);
        }
        else {
            const alias = this._appendTableOrViewNoAliasForFrom(table, params);
            if (alias) {
                if (this._supportTableAliasWithAs) {
                    result += ' as ';
                }
                else {
                    result += ' ';
                }
                result += alias;
            }
        }
        return result;
    }
    _appendTableOrViewNameForFrom(table, _params) {
        const t = (0, ITableOrView_2.__getTableOrViewPrivate)(table);
        return this._escape(t.__name, false);
    }
    _appendTableOrViewNoAliasForFrom(_table, _params) {
        return '';
    }
    _appendRawFragment(rawFragment, params) {
        return rawFragment.__toSql(this, params); // RawFragment has a hidden implemetation of ToSql
    }
    _appendCondition(condition, params) {
        if ((0, SqlBuilder_2.hasToSql)(condition)) {
            return condition.__toSqlForCondition(this, params);
        }
        throw new Error('Conditions must have a __toSqlForCondition method');
    }
    _appendConditionParenthesis(condition, params) {
        if (this._needParenthesis(condition)) {
            return '(' + this._appendCondition(condition, params) + ')';
        }
        return this._appendCondition(condition, params);
    }
    _appendConditionParenthesisExcuding(condition, params, excluding) {
        if (this._needParenthesisExcluding(condition, excluding)) {
            return '(' + this._appendCondition(condition, params) + ')';
        }
        return this._appendCondition(condition, params);
    }
    _appendSql(value, params) {
        return value.__toSql(this, params); // All ValueSource or Column have a hidden implemetation of ToSql
    }
    _appendSqlParenthesis(value, params) {
        if (this._needParenthesis(value)) {
            return '(' + this._appendSql(value, params) + ')';
        }
        return this._appendSql(value, params);
    }
    _appendSqlParenthesisExcluding(value, params, excluding) {
        if (this._needParenthesisExcluding(value, excluding)) {
            return '(' + this._appendSql(value, params) + ')';
        }
        return this._appendSql(value, params);
    }
    _appendSpreadValue(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast = false) {
        if ((0, SqlBuilder_2.hasToSql)(value)) {
            return '(' + this._appendSql(value, params) + ')';
        }
        if (Array.isArray(value)) {
            if (value.length <= 0) {
                return '()';
            }
            let arrayResult = '(' + this._appendValue(value[0], params, columnType, columnTypeName, typeAdapter, forceTypeCast);
            for (let i = 1, length = value.length; i < length; i++) {
                arrayResult += ', ' + this._appendValue(value[i], params, columnType, columnTypeName, typeAdapter, forceTypeCast);
            }
            return arrayResult + ')';
        }
        const adaptedValue = this._transformParamToDB(value, columnType, columnTypeName, typeAdapter);
        return '(' + this._appendParam(adaptedValue, params, columnType, columnTypeName, typeAdapter, forceTypeCast) + ')';
    }
    _appendValue(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast = false) {
        if ((0, SqlBuilder_2.hasToSql)(value)) {
            return this._appendSql(value, params);
        }
        const adaptedValue = this._transformParamToDB(value, columnType, columnTypeName, typeAdapter);
        return this._appendParam(adaptedValue, params, columnType, columnTypeName, typeAdapter, forceTypeCast);
    }
    _appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast = false) {
        if (this._needParenthesis(value)) {
            return '(' + this._appendValue(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast) + ')';
        }
        return this._appendValue(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast);
    }
    _appendValueParenthesisExcluding(value, params, columnType, columnTypeName, typeAdapter, excluding, forceTypeCast = false) {
        if (this._needParenthesisExcluding(value, excluding)) {
            return '(' + this._appendValue(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast) + ')';
        }
        return this._appendValue(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast);
    }
    _appendConditionSql(value, params) {
        return value.__toSqlForCondition(this, params); // All ValueSource or Column have a hidden implemetation of ToSql
    }
    _appendConditionSqlParenthesisExcluding(value, params, excluding) {
        if (this._needParenthesisExcluding(value, excluding)) {
            return '(' + this._appendConditionSql(value, params) + ')';
        }
        return this._appendConditionSql(value, params);
    }
    _appendConditionSqlParenthesis(value, params) {
        if (this._needParenthesis(value)) {
            return '(' + this._appendConditionSql(value, params) + ')';
        }
        return this._appendConditionSql(value, params);
    }
    _appendConditionValue(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast = false) {
        if ((0, SqlBuilder_2.hasToSql)(value)) {
            return this._appendConditionSql(value, params);
        }
        const adaptedValue = this._transformParamToDB(value, columnType, columnTypeName, typeAdapter);
        return this._appendConditionParam(adaptedValue, params, columnType, columnTypeName, typeAdapter, forceTypeCast);
    }
    _appendConditionValueParenthesis(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast = false) {
        if (this._needParenthesis(value)) {
            return '(' + this._appendConditionValue(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast) + ')';
        }
        return this._appendConditionValue(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast);
    }
    _appendConditionValueParenthesisExcluding(value, params, columnType, columnTypeName, typeAdapter, excluding, forceTypeCast = false) {
        if (this._needParenthesisExcluding(value, excluding)) {
            return '(' + this._appendConditionValue(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast) + ')';
        }
        return this._appendConditionValue(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast);
    }
    _transformParamToDB(value, _columnType, columnTypeName, typeAdapter) {
        if (typeAdapter) {
            return typeAdapter.transformValueToDB(value, columnTypeName, this._defaultTypeAdapter);
        }
        else {
            return this._defaultTypeAdapter.transformValueToDB(value, columnTypeName);
        }
    }
    _appendParam(value, params, _columnType, columnTypeName, typeAdapter, forceTypeCast) {
        const placeholder = this._queryRunner.addParam(params, value);
        if (typeAdapter && typeAdapter.transformPlaceholder) {
            return typeAdapter.transformPlaceholder(placeholder, columnTypeName, forceTypeCast, value, this._defaultTypeAdapter);
        }
        else {
            return this._defaultTypeAdapter.transformPlaceholder(placeholder, columnTypeName, forceTypeCast, value);
        }
    }
    _appendConditionParam(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast) {
        return this._appendParam(value, params, columnType, columnTypeName, typeAdapter, forceTypeCast);
    }
    _appendColumnAlias(name, _params) {
        return this._escape(name, true);
    }
    _appendColumnValue(value, params, _isOutermostQuery) {
        return this._appendSql(value, params);
    }
    _buildWith(withData, params) {
        let withs = withData.__withs;
        if (this._isWithGenerated(params)) {
            if (this._generateExternalWith(params)) {
                withs = withData.__withs.filter(value => {
                    return (0, ITableOrView_2.__getTableOrViewPrivate)(value).__hasExternalDependencies;
                });
                this._setGenerateExternalWith(params, false);
            }
            else {
                return '';
            }
        }
        else {
            withs = withData.__withs;
            this._setWithGenerated(params, true);
        }
        if (withs.length <= 0) {
            this._setWithGeneratedFinished(params, true);
            return '';
        }
        let result = '';
        let recursive = false;
        for (let i = 0, length = withs.length; i < length; i++) {
            const withView = (0, SqlBuilder_3.getWithData)(withs[i]);
            if (withView.__type === 'values') {
                const values = this._buildWithValues(withView, params);
                if (values) {
                    if (result) {
                        result += ', ';
                    }
                    result += values;
                }
                continue;
            }
            const customization = withView.__selectData.__customization;
            if (result) {
                result += ', ';
            }
            result += withView.__name;
            result += this._appendWithColumns(withView, params);
            result += ' as ';
            if (customization && customization.beforeWithQuery) {
                result += this._appendRawFragment(customization.beforeWithQuery, params) + ' ';
            }
            result += '(';
            result += this._buildSelect(withView.__selectData, params);
            result += ')';
            if (customization && customization.afterWithQuery) {
                result += ' ' + this._appendRawFragment(customization.afterWithQuery, params);
            }
            recursive = recursive || !!withView.__recursive;
        }
        this._setWithGeneratedFinished(params, true);
        return this._appendWithKeyword(recursive) + ' ' + result + ' ';
    }
    _buildWithValues(withValues, params) {
        let result = withValues.__name;
        let columns = '';
        for (var columnName in withValues) {
            const column = (0, Column_2.__getColumnOfObject)(withValues.__getTableOrView(), columnName);
            if (!column) {
                continue;
            }
            if (columns) {
                columns += ', ';
            }
            const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
            columns += this._appendColumnAlias(columnPrivate.__name, params);
        }
        result += '(' + columns + ')';
        result += ' as (values ';
        const values = withValues.__values;
        let valuesSql = '';
        for (let i = 0, length = values.length; i < length; i++) {
            if (valuesSql) {
                valuesSql += ', ';
            }
            const value = values[i];
            let valueSql = '';
            for (var columnName in withValues) {
                const column = (0, Column_2.__getColumnOfObject)(withValues.__getTableOrView(), columnName);
                if (!column) {
                    continue;
                }
                if (valueSql) {
                    valueSql += ', ';
                }
                valueSql += this._appendValueForColumn(column, value[columnName], params);
            }
            valuesSql += '(' + valueSql + ')';
        }
        result += valuesSql;
        result += ')';
        return result;
    }
    _appendWithColumns(_withData, _params) {
        return '';
    }
    _appendWithKeyword(recursive) {
        if (recursive) {
            return 'with recursive';
        }
        return 'with';
    }
    _inlineSelectAsValue(query, params) {
        const result = '(' + this._buildInlineSelect(query, params) + ')';
        return result;
    }
    _inlineSelectAsValueForCondition(query, params) {
        const result = '(' + this._buildInlineSelect(query, params) + ')';
        return result;
    }
    _buildInlineSelect(query, params) {
        const oldWithGeneratedFinished = this._isWithGeneratedFinished(params);
        const oldGenerateExternalWith = this._generateExternalWith(params);
        this._setGenerateExternalWith(params, true);
        this._setWithGeneratedFinished(params, false);
        const result = this._buildSelectWithColumnsInfo(query, params, {}, false);
        this._setWithGeneratedFinished(params, oldWithGeneratedFinished);
        this._setGenerateExternalWith(params, oldGenerateExternalWith);
        return result;
    }
    _buildSelect(query, params) {
        this._ensureRootQuery(query, params);
        const isOutermostQuery = this._isCurrentRootQuery(query, params);
        const result = this._buildSelectWithColumnsInfo(query, params, {}, isOutermostQuery);
        this._resetRootQuery(query, params);
        return result;
    }
    _appendCompoundOperator(compoundOperator, _params) {
        switch (compoundOperator) {
            case 'union':
                return ' union ';
            case 'unionAll':
                return ' union all ';
            case 'intersect':
                return ' intersect ';
            case 'intersectAll':
                return ' intersect all ';
            case 'except':
                return ' except ';
            case 'exceptAll':
                return ' except all ';
            case 'minus':
                return ' except ';
            case 'minusAll':
                return ' except all ';
            default:
                throw new Error('Invalid compound operator: ' + compoundOperator);
        }
    }
    _buildSelectWithColumnsInfoForCompound(query, params, columnsForInsert, isOutermostQuery) {
        const result = this._buildSelectWithColumnsInfo(query, params, columnsForInsert, isOutermostQuery);
        if (query.__limit !== undefined || query.__offset !== undefined || query.__orderBy || query.__customization?.beforeOrderByItems || query.__customization?.afterOrderByItems) {
            return '(' + result + ')';
        }
        return result;
    }
    _buildFromJoins(tables, joins, requiredTablesOrViews, params) {
        let fromJoins = '';
        if (tables && tables.length > 0) {
            let requireComma = false;
            for (let i = 0, length = tables.length; i < length; i++) {
                if (requireComma) {
                    fromJoins += ', ';
                }
                fromJoins += this._appendTableOrViewName(tables[i], params);
                requireComma = true;
            }
        }
        if (!joins || joins.length <= 0) {
            return fromJoins;
        }
        for (let i = 0, length = joins.length; i < length; i++) {
            const join = joins[i];
            if (join.__optional) {
                if (!requiredTablesOrViews.has(join.__tableOrView)) {
                    continue;
                }
            }
            switch (join.__joinType) {
                case 'join':
                    fromJoins += ' join ';
                    break;
                case 'innerJoin':
                    fromJoins += ' inner join ';
                    break;
                case 'leftJoin':
                    fromJoins += ' left join ';
                    break;
                case 'leftOuterJoin':
                    fromJoins += ' left outer join ';
                    break;
                default:
                    throw new Error('Invalid join type: ' + join.__joinType);
            }
            fromJoins += this._appendTableOrViewName(join.__tableOrView, params);
            if (join.__on) {
                const onCondition = this._appendCondition(join.__on, params);
                if (onCondition) {
                    fromJoins += ' on ' + onCondition;
                }
            }
        }
        return fromJoins;
    }
    _buildSelectWithColumnsInfo(query, params, columnsForInsert, isOutermostQuery) {
        const oldSafeTableOrView = this._getSafeTableOrView(params);
        const oldWithGenerated = this._isWithGenerated(params);
        const oldWithGeneratedFinished = this._isWithGeneratedFinished(params);
        const oldAggregateArrayWrapped = this._isAggregateArrayWrapped(params);
        const customization = query.__customization;
        const needAgggregateArrayWrapper = this._needAgggregateArrayWrapper(query, params);
        const aggregateId = needAgggregateArrayWrapper ? this._generateUnique() : 0;
        if (query.__type === 'compound') {
            this._setSafeTableOrView(params, undefined);
            let selectQuery = '';
            if (needAgggregateArrayWrapper) {
                selectQuery += this._appendAggragateArrayWrapperBegin(query, params, aggregateId);
                this._setAggregateArrayWrapped(params, true);
            }
            if (customization && customization.beforeQuery) {
                selectQuery += this._appendRawFragment(customization.beforeQuery, params) + ' ';
            }
            selectQuery += this._buildWith(query, params);
            selectQuery += this._buildSelectWithColumnsInfoForCompound(query.__firstQuery, params, columnsForInsert, isOutermostQuery);
            selectQuery += this._appendCompoundOperator(query.__compoundOperator, params);
            selectQuery += this._buildSelectWithColumnsInfoForCompound(query.__secondQuery, params, columnsForInsert, isOutermostQuery);
            if (!query.__asInlineAggregatedArrayValue || !this._supportOrderByWhenAggregateArray || this._isAggregateArrayWrapped(params)) {
                selectQuery += this._buildSelectOrderBy(query, params);
            }
            if (!query.__asInlineAggregatedArrayValue || !this._supportLimitWhenAggregateArray || this._isAggregateArrayWrapped(params)) {
                selectQuery += this._buildSelectLimitOffset(query, params);
            }
            selectQuery += this._buildSelectAsAggregatedArray(query, params);
            if (customization && customization.afterQuery) {
                selectQuery += ' ' + this._appendRawFragment(customization.afterQuery, params);
            }
            if (needAgggregateArrayWrapper) {
                selectQuery += this._appendAggragateArrayWrapperEnd(query, params, aggregateId);
            }
            this._setSafeTableOrView(params, oldSafeTableOrView);
            this._setWithGenerated(params, oldWithGenerated);
            this._setWithGeneratedFinished(params, oldWithGeneratedFinished);
            this._setAggregateArrayWrapped(params, oldAggregateArrayWrapped);
            return selectQuery;
        }
        const requiredTablesOrViews = query.__requiredTablesOrViews;
        const oldFakeNameOf = this._getFakeNamesOf(params);
        if (oldFakeNameOf) {
            if (requiredTablesOrViews) {
                const newFakeNameOf = new Set();
                requiredTablesOrViews.forEach(v => {
                    if (oldFakeNameOf.has(v)) {
                        newFakeNameOf.add(v);
                    }
                });
                if (newFakeNameOf.size > 0) {
                    this._setFakeNamesOf(params, newFakeNameOf);
                }
                else {
                    this._setFakeNamesOf(params, undefined);
                }
            }
            else {
                this._setFakeNamesOf(params, undefined);
            }
        }
        const tables = query.__tablesOrViews;
        const tablesLength = tables.length;
        const joins = query.__joins;
        let hasJoins = false;
        for (let i = 0, length = joins.length; i < length; i++) {
            const join = joins[i];
            if (join.__optional) {
                if (!requiredTablesOrViews.has(join.__tableOrView)) {
                    continue;
                }
            }
            hasJoins = true;
            break;
        }
        if (tablesLength === 1 && !hasJoins) {
            this._setSafeTableOrView(params, tables[0]);
        }
        else {
            this._setSafeTableOrView(params, undefined);
        }
        let selectQuery = '';
        if (needAgggregateArrayWrapper) {
            selectQuery += this._appendAggragateArrayWrapperBegin(query, params, aggregateId);
            this._setAggregateArrayWrapped(params, true);
        }
        if (customization && customization.beforeQuery) {
            selectQuery += this._appendRawFragment(customization.beforeQuery, params) + ' ';
        }
        selectQuery += this._buildWith(query, params);
        selectQuery += 'select ';
        if (customization && customization.afterSelectKeyword) {
            selectQuery += this._appendRawFragment(customization.afterSelectKeyword, params) + ' ';
        }
        if (query.__distinct) {
            selectQuery += 'distinct ';
        }
        if (customization && customization.beforeColumns) {
            selectQuery += this._appendRawFragment(customization.beforeColumns, params) + ' ';
        }
        const columns = {};
        (0, SqlBuilder_1.flattenQueryColumns)(query.__columns, columns, '');
        if (needAgggregateArrayWrapper || !this._needAgggregateArrayColumnsTransformation(query, params)) {
            let requireComma = false;
            for (const property in columns) {
                if (requireComma) {
                    selectQuery += ', ';
                }
                const columnForInsert = columnsForInsert[property];
                selectQuery += this._appendSelectColumn(columns[property], params, columnForInsert, isOutermostQuery);
                if (property) {
                    selectQuery += ' as ' + this._appendColumnAlias(property, params);
                }
                requireComma = true;
            }
        }
        else {
            let aggregatedArrayColumns;
            if (query.__oneColumn) {
                aggregatedArrayColumns = query.__columns['result'];
                if (!aggregatedArrayColumns) {
                    throw new Error('Illegal state: result column for a select one column not found');
                }
            }
            else {
                aggregatedArrayColumns = query.__columns;
            }
            selectQuery += this._appendAggragateArrayColumns(aggregatedArrayColumns, false, params, query);
        }
        if (tablesLength <= 0) {
            selectQuery += this._fromNoTable();
        }
        else {
            selectQuery += ' from ';
            selectQuery += this._buildFromJoins(tables, joins, query.__requiredTablesOrViews, params);
        }
        const where = query.__where;
        if (where) {
            const whereCondition = this._appendCondition(where, params);
            if (whereCondition) {
                selectQuery += ' where ' + whereCondition;
            }
        }
        // Oracle recursive
        const startWith = query.__startWith;
        if (startWith) {
            const startWithCondition = this._appendCondition(startWith, params);
            if (startWithCondition) {
                selectQuery += ' start with ' + startWithCondition;
            }
        }
        // Oracle recursive
        const connectdBy = query.__connectBy;
        if (connectdBy) {
            const connectByCondition = this._appendCondition(connectdBy, params);
            if (connectByCondition) {
                if (query.__connectByNoCycle) {
                    selectQuery += ' connect by nocycle ' + connectByCondition;
                }
                else {
                    selectQuery += ' connect by ' + connectByCondition;
                }
            }
        }
        let requireComma = false;
        const groupBy = query.__groupBy;
        for (let i = 0, length = groupBy.length; i < length; i++) {
            if (requireComma) {
                selectQuery += ', ';
            }
            else {
                selectQuery += ' group by ';
            }
            selectQuery += this._appendSelectColumn(groupBy[i], params, undefined, isOutermostQuery);
            requireComma = true;
        }
        const having = query.__having;
        if (having) {
            const havingCondition = this._appendCondition(having, params);
            if (havingCondition) {
                selectQuery += ' having ' + havingCondition;
            }
        }
        if (customization && customization.customWindow) {
            selectQuery += ' window ';
            selectQuery += this._appendRawFragment(customization.customWindow, params);
        }
        if (!query.__asInlineAggregatedArrayValue || !this._supportOrderByWhenAggregateArray || this._isAggregateArrayWrapped(params)) {
            selectQuery += this._buildSelectOrderBy(query, params);
        }
        if (!query.__asInlineAggregatedArrayValue || !this._supportLimitWhenAggregateArray || this._isAggregateArrayWrapped(params)) {
            selectQuery += this._buildSelectLimitOffset(query, params);
        }
        selectQuery += this._buildSelectAsAggregatedArray(query, params);
        if (customization && customization.afterQuery) {
            selectQuery += ' ' + this._appendRawFragment(customization.afterQuery, params);
        }
        if (needAgggregateArrayWrapper) {
            selectQuery += this._appendAggragateArrayWrapperEnd(query, params, aggregateId);
        }
        this._setSafeTableOrView(params, oldSafeTableOrView);
        this._setFakeNamesOf(params, oldFakeNameOf);
        this._setWithGenerated(params, oldWithGenerated);
        this._setWithGeneratedFinished(params, oldWithGeneratedFinished);
        this._setAggregateArrayWrapped(params, oldAggregateArrayWrapped);
        return selectQuery;
    }
    _appendSelectColumn(value, params, columnForInsert, isOutermostQuery) {
        if (columnForInsert) {
            const sql = this._appendCustomBooleanRemapForColumnIfRequired(columnForInsert, value, params);
            if (sql) {
                return sql;
            }
        }
        return this._appendColumnValue(value, params, isOutermostQuery);
    }
    _fromNoTable() {
        return '';
    }
    _buildSelectOrderBy(query, params) {
        const orderBy = query.__orderBy;
        if (!orderBy) {
            let orderByColumns = '';
            const customization = query.__customization;
            if (customization && customization.beforeOrderByItems) {
                orderByColumns += this._appendRawFragment(customization.beforeOrderByItems, params);
            }
            if (customization && customization.afterOrderByItems) {
                if (orderByColumns) {
                    orderByColumns += ', ';
                }
                orderByColumns += this._appendRawFragment(customization.afterOrderByItems, params);
            }
            if (!orderByColumns) {
                return '';
            }
            if (query.__orderingSiblingsOnly) {
                // Oracle recursive
                return ' order siblings by ' + orderByColumns;
            }
            else {
                return ' order by ' + orderByColumns;
            }
        }
        let orderByColumns = '';
        const customization = query.__customization;
        if (customization && customization.beforeOrderByItems) {
            orderByColumns += this._appendRawFragment(customization.beforeOrderByItems, params);
        }
        for (const entry of orderBy) {
            if (orderByColumns) {
                orderByColumns += ', ';
            }
            const order = entry.order;
            if (!order) {
                orderByColumns += this._appendOrderByColumnAlias(entry, query, params);
            }
            else
                switch (order) {
                    case 'asc':
                    case 'desc':
                    case 'asc nulls first':
                    case 'asc nulls last':
                    case 'desc nulls first':
                    case 'desc nulls last':
                        orderByColumns += this._appendOrderByColumnAlias(entry, query, params) + ' ' + order;
                        break;
                    case 'insensitive':
                    case 'asc insensitive':
                    case 'desc insensitive':
                    case 'asc nulls first insensitive':
                    case 'asc nulls last insensitive':
                    case 'desc nulls first insensitive':
                    case 'desc nulls last insensitive': {
                        let sqlOrder = order.substring(0, order.length - 12);
                        if (sqlOrder) {
                            sqlOrder = ' ' + sqlOrder;
                        }
                        orderByColumns += this._appendOrderByColumnAliasInsensitive(entry, query, params) + sqlOrder;
                        break;
                    }
                    default:
                        throw new Error('Invalid order by: ' + order);
                }
        }
        if (customization && customization.afterOrderByItems) {
            if (orderByColumns) {
                orderByColumns += ', ';
            }
            orderByColumns += this._appendRawFragment(customization.afterOrderByItems, params);
        }
        if (!orderByColumns) {
            return '';
        }
        if (query.__orderingSiblingsOnly) {
            // Oracle recursive
            return ' order siblings by ' + orderByColumns;
        }
        else {
            return ' order by ' + orderByColumns;
        }
    }
    _appendOrderByColumnAlias(entry, query, params) {
        const expression = entry.expression;
        const columns = query.__columns;
        if (typeof expression === 'string') {
            const column = (0, SqlBuilder_1.getQueryColumn)(columns, expression);
            if (!column) {
                throw new Error('Column ' + expression + ' included in the order by not found in the select clause');
            }
            return this._appendColumnAlias(expression, params);
        }
        else if ((0, values_1.isValueSource)(expression)) {
            const oldSafeTableOrView = this._getSafeTableOrView(params);
            this._setSafeTableOrView(params, undefined);
            const result = this._appendSql(expression, params);
            this._setSafeTableOrView(params, oldSafeTableOrView);
            return result;
        }
        else {
            const oldSafeTableOrView = this._getSafeTableOrView(params);
            this._setSafeTableOrView(params, undefined);
            const result = this._appendRawFragment(expression, params);
            this._setSafeTableOrView(params, oldSafeTableOrView);
            return result;
        }
    }
    _appendOrderByColumnAliasInsensitive(entry, query, params) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        const stringColumn = this._isStringOrderByColumn(entry, query);
        if (!stringColumn) {
            // Ignore the insensitive term, it do nothing
            return this._appendOrderByColumnAlias(entry, query, params);
        }
        else if (collation) {
            return this._appendOrderByColumnAlias(entry, query, params) + ' collate ' + collation;
        }
        else if (collation === '') {
            return this._appendOrderByColumnAlias(entry, query, params);
        }
        else {
            return 'lower(' + this._appendOrderByColumnAlias(entry, query, params) + ')';
        }
    }
    _isStringOrderByColumn(entry, query) {
        const expression = entry.expression;
        const columns = query.__columns;
        if (typeof expression === 'string') {
            const column = (0, SqlBuilder_1.getQueryColumn)(columns, expression);
            if (!column) {
                throw new Error('Column ' + expression + ' included in the order by not found in the select clause');
            }
            return (0, values_1.__isStringValueSource)((0, values_2.__getValueSourcePrivate)(column));
        }
        else if ((0, values_1.isValueSource)(expression)) {
            return (0, values_1.__isStringValueSource)((0, values_2.__getValueSourcePrivate)(expression));
        }
        else {
            return false;
        }
    }
    _buildSelectLimitOffset(query, params) {
        let result = '';
        const offset = query.__offset;
        if (offset !== null && offset !== undefined) {
            result += ' offset ' + this._appendValue(offset, params, 'int', 'int', undefined) + ' rows';
        }
        const limit = query.__limit;
        if (limit !== null && limit !== undefined) {
            result += ' fetch next ' + this._appendValue(limit, params, 'int', 'int', undefined) + ' rows only';
        }
        return result;
    }
    _buildInsertMultiple(query, params) {
        const multiple = query.__multiple;
        if (!multiple) {
            throw new Error('Exepected a multiple insert');
        }
        if (multiple.length <= 0) {
            return '';
        }
        this._ensureRootQuery(query, params);
        const oldSafeTableOrView = this._getSafeTableOrView(params);
        const oldFakeNameOf = this._getFakeNamesOf(params);
        this._setFakeNamesOf(params, undefined);
        const table = query.__table;
        const customization = query.__customization;
        this._setSafeTableOrView(params, table);
        let insertQuery = '';
        if (customization && customization.beforeQuery) {
            insertQuery += this._appendRawFragment(customization.beforeQuery, params) + ' ';
        }
        if (this._insertSupportWith) {
            insertQuery += this._buildWith(query, params);
        }
        insertQuery += 'insert ';
        if (customization && customization.afterInsertKeyword) {
            insertQuery += this._appendRawFragment(customization.afterInsertKeyword, params) + ' ';
        }
        insertQuery += this._buildInsertOnConflictBeforeInto(query, params);
        insertQuery += 'into ';
        insertQuery += this._appendTableOrViewName(table, params);
        const shape = query.__shape;
        let usedColumns = {};
        let translationToShape;
        if (shape) { // Follow shape order
            for (let i = 0, length = multiple.length; i < length; i++) {
                const sets = multiple[i];
                const properties = Object.getOwnPropertyNames(sets);
                for (let j = 0, length = properties.length; j < length; j++) {
                    const property = properties[j];
                    const columnName = shape[property];
                    if (typeof columnName !== 'string') {
                        continue;
                    }
                    usedColumns[columnName] = true;
                }
            }
            // Sort according the shape
            const unorderedUsedColumn = usedColumns;
            usedColumns = {};
            translationToShape = {};
            const properties = Object.getOwnPropertyNames(shape);
            for (let i = 0, length = properties.length; i < length; i++) {
                const property = properties[i];
                const columnName = shape[property];
                const column = (0, Column_2.__getColumnOfObject)(table, columnName);
                if (!column) {
                    // Additional property provided in the value object
                    // Skipped because it is not part of the table
                    // This allows to have more complex objects used in the query
                    continue;
                }
                if (!(columnName in unorderedUsedColumn)) {
                    // No value set for that property in the shape
                    continue;
                }
                usedColumns[columnName] = true;
                translationToShape[columnName] = property;
            }
        }
        else { // No shape, follow set order
            for (let i = 0, length = multiple.length; i < length; i++) {
                const sets = multiple[i];
                const properties = Object.getOwnPropertyNames(sets);
                for (let j = 0, length = properties.length; j < length; j++) {
                    const columnName = properties[j];
                    usedColumns[columnName] = true;
                }
            }
        }
        let columns = '';
        const nextSequenceValues = [];
        for (var columnName in table) {
            const column = (0, Column_2.__getColumnOfObject)(table, columnName);
            if (!column) {
                continue;
            }
            const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
            if (!columnPrivate.__sequenceName) {
                continue;
            }
            if (columns) {
                columns += ', ';
            }
            columns += this._appendRawColumnName(column, params);
            nextSequenceValues.push(columnPrivate.__sequenceName);
        }
        for (let columnName in usedColumns) {
            const column = (0, Column_2.__getColumnOfObject)(table, columnName);
            if (!column) {
                // Additional property provided in the value object
                // Skipped because it is not part of the table
                // This allows to have more complex objects used in the query
                continue;
            }
            if (columns) {
                columns += ', ';
            }
            columns += this._appendRawColumnName(column, params);
        }
        insertQuery += ' (' + columns + ')';
        insertQuery += this._buildInsertOutput(query, params);
        let multipleValues = '';
        for (let i = 0, length = multiple.length; i < length; i++) {
            let values = '';
            for (let j = 0, length = nextSequenceValues.length; j < length; j++) {
                if (values) {
                    values += ', ';
                }
                const sequenceName = nextSequenceValues[j];
                values += this._nextSequenceValue(params, sequenceName);
            }
            const sets = multiple[i];
            for (let columnName in usedColumns) {
                const column = (0, Column_2.__getColumnOfObject)(table, columnName);
                if (!column) {
                    // Additional property provided in the value object
                    // Skipped because it is not part of the table
                    // This allows to have more complex objects used in the query
                    continue;
                }
                if (values) {
                    values += ', ';
                }
                let setPropertyName;
                if (translationToShape) {
                    setPropertyName = translationToShape[columnName];
                }
                else {
                    setPropertyName = columnName;
                }
                const value = sets[setPropertyName];
                const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
                const sequenceName = columnPrivate.__sequenceName;
                if (!(setPropertyName in sets) && sequenceName) {
                    values += this._nextSequenceValue(params, sequenceName);
                }
                else {
                    values += this._appendValueForColumn(column, value, params);
                }
            }
            if (multipleValues) {
                multipleValues += ', (' + values + ')';
            }
            else {
                multipleValues = '(' + values + ')';
            }
        }
        insertQuery += ' values ' + multipleValues;
        insertQuery += this._buildInsertOnConflictBeforeReturning(query, params);
        insertQuery += this._buildInsertReturning(query, params);
        if (customization && customization.afterQuery) {
            insertQuery += ' ' + this._appendRawFragment(customization.afterQuery, params);
        }
        this._setSafeTableOrView(params, oldSafeTableOrView);
        this._setFakeNamesOf(params, oldFakeNameOf);
        this._resetRootQuery(query, params);
        return insertQuery;
    }
    _appendCustomBooleanRemapForColumnIfRequired(column, value, params) {
        const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
        const columnTypeAdapter = columnPrivate.__typeAdapter;
        const columnTypeName = columnPrivate.__valueTypeName;
        const columnType = columnPrivate.__valueType;
        if (!(0, values_1.__isBooleanValueSource)(columnPrivate)) {
            return null; // non-boolean
        }
        if (columnTypeAdapter instanceof TypeAdapter_1.CustomBooleanTypeAdapter) {
            if ((0, Column_1.isColumn)(value)) {
                const valuePrivate = (0, Column_2.__getColumnPrivate)(value);
                const valueTypeAdapter = valuePrivate.__typeAdapter;
                if (valueTypeAdapter instanceof TypeAdapter_1.CustomBooleanTypeAdapter) {
                    if (columnTypeAdapter.trueValue === valueTypeAdapter.trueValue && columnTypeAdapter.falseValue === valueTypeAdapter.falseValue) {
                        return this._appendRawColumnName(value, params); // same boolean as column
                    }
                    if (columnPrivate.__optionalType === 'required') {
                        // remapped
                        return 'case when ' + this._appendRawColumnName(value, params) + ' = ' + this._appendLiteralValue(valueTypeAdapter.trueValue, params) + ' then ' + this._appendLiteralValue(columnTypeAdapter.trueValue, params) + ' else ' + this._appendLiteralValue(columnTypeAdapter.falseValue, params) + ' end';
                    }
                    else {
                        // remapped
                        return 'case ' + this._appendRawColumnName(value, params) + ' when ' + this._appendLiteralValue(valueTypeAdapter.trueValue, params) + ' then ' + this._appendLiteralValue(columnTypeAdapter.trueValue, params) + ' when ' + this._appendLiteralValue(valueTypeAdapter.falseValue, params) + ' then ' + this._appendLiteralValue(columnTypeAdapter.falseValue, params) + ' else null end';
                    }
                }
                else {
                    if (columnPrivate.__optionalType === 'required') {
                        // remapped
                        return 'case when ' + this._appendConditionValue(value, params, columnType, columnTypeName, columnTypeAdapter) + ' then ' + this._appendLiteralValue(columnTypeAdapter.trueValue, params) + ' else ' + this._appendLiteralValue(columnTypeAdapter.falseValue, params) + ' end';
                    }
                    else {
                        // remapped
                        return 'case ' + this._appendValue(value, params, columnType, columnTypeName, columnTypeAdapter) + ' when ' + this._trueValue + ' then ' + this._appendLiteralValue(columnTypeAdapter.trueValue, params) + ' when ' + this._falseValue + ' then ' + this._appendLiteralValue(columnTypeAdapter.falseValue, params) + ' else null end';
                    }
                }
            }
            else if ((0, values_1.isValueSource)(value)) {
                // There are some boolean expressions involved
                if (columnPrivate.__optionalType === 'required') {
                    // remapped
                    return 'case when ' + this._appendConditionValue(value, params, columnType, columnTypeName, columnTypeAdapter) + ' then ' + this._appendLiteralValue(columnTypeAdapter.trueValue, params) + ' else ' + this._appendLiteralValue(columnTypeAdapter.falseValue, params) + ' end';
                }
                else {
                    // remapped
                    return 'case when ' + this._appendConditionValue(value, params, columnType, columnTypeName, columnTypeAdapter) + ' then ' + this._appendLiteralValue(columnTypeAdapter.trueValue, params) + ' when not ' + this._appendConditionValueParenthesis(value, params, columnType, columnTypeName, columnTypeAdapter) + ' then ' + this._appendLiteralValue(columnTypeAdapter.falseValue, params) + ' else null end';
                }
            }
            else {
                if (columnPrivate.__optionalType === 'required') {
                    // remapped
                    return 'case when ' + this._appendConditionValue(value, params, columnType, columnTypeName, columnTypeAdapter) + ' then ' + this._appendLiteralValue(columnTypeAdapter.trueValue, params) + ' else ' + this._appendLiteralValue(columnTypeAdapter.falseValue, params) + ' end';
                }
                else {
                    // remapped
                    return 'case ' + this._appendValue(value, params, columnType, columnTypeName, columnTypeAdapter) + ' when ' + this._trueValue + ' then ' + this._appendLiteralValue(columnTypeAdapter.trueValue, params) + ' when ' + this._falseValue + ' then ' + this._appendLiteralValue(columnTypeAdapter.falseValue, params) + ' else null end';
                }
            }
        }
        // if value is column and its type adapter is CustomBooleanTypeAdapter append value will be required to normalize value
        // if not it is same boolean, nothing to transform here
        return null;
    }
    _appendValueForColumn(column, value, params, forceTypeCast = false) {
        const sql = this._appendCustomBooleanRemapForColumnIfRequired(column, value, params);
        if (sql) {
            return sql;
        }
        const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
        return this._appendValue(value, params, columnPrivate.__valueType, columnPrivate.__valueTypeName, columnPrivate.__typeAdapter, forceTypeCast);
    }
    _buildInsertDefaultValues(query, params) {
        this._ensureRootQuery(query, params);
        const oldSafeTableOrView = this._getSafeTableOrView(params);
        const oldFakeNameOf = this._getFakeNamesOf(params);
        this._setFakeNamesOf(params, undefined);
        const table = query.__table;
        const customization = query.__customization;
        this._setSafeTableOrView(params, table);
        let insertQuery = '';
        if (customization && customization.beforeQuery) {
            insertQuery += this._appendRawFragment(customization.beforeQuery, params) + ' ';
        }
        if (this._insertSupportWith) {
            insertQuery += this._buildWith(query, params);
        }
        insertQuery += 'insert ';
        if (customization && customization.afterInsertKeyword) {
            insertQuery += this._appendRawFragment(customization.afterInsertKeyword, params) + ' ';
        }
        insertQuery += this._buildInsertOnConflictBeforeInto(query, params);
        insertQuery += 'into ';
        insertQuery += this._appendTableOrViewName(table, params);
        let columns = '';
        const sequences = [];
        for (var columnName in table) {
            const column = (0, Column_2.__getColumnOfObject)(table, columnName);
            if (!column) {
                continue;
            }
            const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
            if (!columnPrivate.__sequenceName) {
                continue;
            }
            if (columns) {
                columns += ', ';
            }
            columns += this._appendRawColumnName(column, params);
            sequences.push(columnPrivate.__sequenceName);
        }
        if (columns) {
            insertQuery += ' (' + columns + ')';
        }
        insertQuery += this._buildInsertOutput(query, params);
        let values = '';
        for (let i = 0, length = sequences.length; i < length; i++) {
            const sequenceName = sequences[i];
            if (values) {
                values += ', ';
            }
            values += this._nextSequenceValue(params, sequenceName);
        }
        if (values) {
            insertQuery += ' values (' + values + ')';
        }
        else {
            insertQuery += ' default values';
        }
        insertQuery += this._buildInsertOnConflictBeforeReturning(query, params);
        insertQuery += this._buildInsertReturning(query, params);
        if (customization && customization.afterQuery) {
            insertQuery += ' ' + this._appendRawFragment(customization.afterQuery, params);
        }
        this._setSafeTableOrView(params, oldSafeTableOrView);
        this._setFakeNamesOf(params, oldFakeNameOf);
        this._resetRootQuery(query, params);
        return insertQuery;
    }
    _buildInsert(query, params) {
        this._ensureRootQuery(query, params);
        const oldSafeTableOrView = this._getSafeTableOrView(params);
        const oldFakeNameOf = this._getFakeNamesOf(params);
        this._setFakeNamesOf(params, undefined);
        const table = query.__table;
        const sets = query.__sets;
        const customization = query.__customization;
        this._setSafeTableOrView(params, table);
        let insertQuery = '';
        if (customization && customization.beforeQuery) {
            insertQuery += this._appendRawFragment(customization.beforeQuery, params) + ' ';
        }
        if (this._insertSupportWith) {
            insertQuery += this._buildWith(query, params);
        }
        insertQuery += 'insert ';
        if (customization && customization.afterInsertKeyword) {
            insertQuery += this._appendRawFragment(customization.afterInsertKeyword, params) + ' ';
        }
        insertQuery += this._buildInsertOnConflictBeforeInto(query, params);
        insertQuery += 'into ';
        insertQuery += this._appendTableOrViewName(table, params);
        const shape = query.__shape;
        let columnsInShape;
        if (shape) {
            columnsInShape = {};
            for (let property in shape) {
                const colunName = shape[property];
                if (typeof colunName === 'string') {
                    columnsInShape[colunName] = true;
                }
            }
        }
        let columns = '';
        const sequences = [];
        for (var columnName in table) {
            if (columnsInShape) {
                if (columnName in columnsInShape) {
                    continue;
                }
            }
            else {
                if (columnName in sets) {
                    continue;
                }
            }
            const column = (0, Column_2.__getColumnOfObject)(table, columnName);
            if (!column) {
                continue;
            }
            const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
            if (!columnPrivate.__sequenceName) {
                continue;
            }
            if (columns) {
                columns += ', ';
            }
            columns += this._appendRawColumnName(column, params);
            sequences.push(columnPrivate.__sequenceName);
        }
        if (shape) { // Follow shape order
            const properties = Object.getOwnPropertyNames(shape);
            for (let i = 0, length = properties.length; i < length; i++) {
                const property = properties[i];
                const columnName = shape[property];
                const column = (0, Column_2.__getColumnOfObject)(table, columnName);
                if (!column) {
                    // Additional property provided in the value object
                    // Skipped because it is not part of the table
                    // This allows to have more complex objects used in the query
                    continue;
                }
                if (!(property in sets)) {
                    // No value set for that property in the shape
                    continue;
                }
                if (columns) {
                    columns += ', ';
                }
                columns += this._appendRawColumnName(column, params);
            }
        }
        else { // No shape, follow set order
            const properties = Object.getOwnPropertyNames(sets);
            for (let i = 0, length = properties.length; i < length; i++) {
                const property = properties[i];
                const column = (0, Column_2.__getColumnOfObject)(table, property);
                if (!column) {
                    // Additional property provided in the value object
                    // Skipped because it is not part of the table
                    // This allows to have more complex objects used in the query
                    continue;
                }
                if (columns) {
                    columns += ', ';
                }
                columns += this._appendRawColumnName(column, params);
            }
        }
        insertQuery += ' (' + columns + ')';
        insertQuery += this._buildInsertOutput(query, params);
        let values = '';
        for (let i = 0, length = sequences.length; i < length; i++) {
            const sequenceName = sequences[i];
            if (values) {
                values += ', ';
            }
            values += this._nextSequenceValue(params, sequenceName);
        }
        if (shape) { // Follow shape order
            const properties = Object.getOwnPropertyNames(shape);
            for (let i = 0, length = properties.length; i < length; i++) {
                const property = properties[i];
                const columnName = shape[property];
                const column = (0, Column_2.__getColumnOfObject)(table, columnName);
                if (!column) {
                    // Additional property provided in the value object
                    // Skipped because it is not part of the table
                    // This allows to have more complex objects used in the query
                    continue;
                }
                if (!(property in sets)) {
                    // No value set for that property in the shape
                    continue;
                }
                if (values) {
                    values += ', ';
                }
                const value = sets[property];
                values += this._appendValueForColumn(column, value, params);
            }
        }
        else { // No shape, follow set order
            const properties = Object.getOwnPropertyNames(sets);
            for (let i = 0, length = properties.length; i < length; i++) {
                const property = properties[i];
                const column = (0, Column_2.__getColumnOfObject)(table, property);
                if (!column) {
                    // Additional property provided in the value object
                    // Skipped because it is not part of the table
                    // This allows to have more complex objects used in the query
                    continue;
                }
                if (values) {
                    values += ', ';
                }
                const value = sets[property];
                values += this._appendValueForColumn(column, value, params);
            }
        }
        insertQuery += ' values (' + values + ')';
        insertQuery += this._buildInsertOnConflictBeforeReturning(query, params);
        insertQuery += this._buildInsertReturning(query, params);
        if (customization && customization.afterQuery) {
            insertQuery += ' ' + this._appendRawFragment(customization.afterQuery, params);
        }
        this._setSafeTableOrView(params, oldSafeTableOrView);
        this._setFakeNamesOf(params, oldFakeNameOf);
        this._resetRootQuery(query, params);
        return insertQuery;
    }
    _buildInsertFromSelect(query, params) {
        const from = query.__from;
        if (!from) {
            throw new Error('Exepected an insert from a subquery');
        }
        this._ensureRootQuery(query, params);
        const oldSafeTableOrView = this._getSafeTableOrView(params);
        const oldFakeNameOf = this._getFakeNamesOf(params);
        this._setFakeNamesOf(params, undefined);
        const table = query.__table;
        const selectColumns = from.__columns;
        const customization = query.__customization;
        this._setSafeTableOrView(params, table);
        let insertQuery = '';
        if (customization && customization.beforeQuery) {
            insertQuery += this._appendRawFragment(customization.beforeQuery, params) + ' ';
        }
        if (this._insertSupportWith) {
            insertQuery += this._buildWith(query, params);
        }
        insertQuery += 'insert ';
        if (customization && customization.afterInsertKeyword) {
            insertQuery += this._appendRawFragment(customization.afterInsertKeyword, params) + ' ';
        }
        insertQuery += this._buildInsertOnConflictBeforeInto(query, params);
        insertQuery += 'into ';
        insertQuery += this._appendTableOrViewName(table, params);
        const columnsForInsert = {};
        let columns = '';
        const addedColumns = [];
        for (var columnName in table) {
            if (columnName in selectColumns) {
                continue;
            }
            const column = (0, Column_2.__getColumnOfObject)(table, columnName);
            if (!column) {
                continue;
            }
            const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
            if (!columnPrivate.__sequenceName) {
                continue;
            }
            addedColumns.push(columnName);
            columnsForInsert[columnName] = column;
            selectColumns[columnName] = new ValueSourceImpl_1.SequenceValueSource('_nextSequenceValue', columnPrivate.__sequenceName, columnPrivate.__valueType, columnPrivate.__valueTypeName, 'required', columnPrivate.__typeAdapter);
        }
        const properties = Object.getOwnPropertyNames(selectColumns);
        for (let i = 0, length = properties.length; i < length; i++) {
            if (columns) {
                columns += ', ';
            }
            const property = properties[i];
            const column = (0, Column_2.__getColumnOfObject)(table, property);
            if (column) {
                columns += this._appendRawColumnName(column, params);
                columnsForInsert[property] = column;
            }
            else {
                throw new Error('Unable to find the column "' + property + ' in the table "' + this._getTableOrViewVisibleName(table) + '". The column is not included in the table definition');
            }
        }
        insertQuery += ' (' + columns + ')';
        insertQuery += this._buildInsertOutput(query, params);
        insertQuery += ' ' + this._buildSelectWithColumnsInfo(from, params, columnsForInsert, false);
        insertQuery += this._buildInsertOnConflictBeforeReturning(query, params);
        insertQuery += this._buildInsertReturning(query, params);
        if (customization && customization.afterQuery) {
            insertQuery += ' ' + this._appendRawFragment(customization.afterQuery, params);
        }
        for (let i = 0, length = addedColumns.length; i < length; i++) {
            const columnName = addedColumns[i];
            delete selectColumns[columnName];
        }
        this._setSafeTableOrView(params, oldSafeTableOrView);
        this._setFakeNamesOf(params, oldFakeNameOf);
        this._resetRootQuery(query, params);
        return insertQuery;
    }
    _buildInsertOutput(_query, _params) {
        return '';
    }
    _buildInsertReturning(query, params) {
        const idColumn = query.__idColumn;
        if (idColumn) {
            this._setContainsInsertReturningClause(params, true);
            return ' returning ' + this._appendSql(idColumn, params);
        }
        const isOutermostQuery = this._isCurrentRootQuery(query, params);
        const result = this._buildQueryReturning(query.__columns, params, isOutermostQuery);
        this._setContainsInsertReturningClause(params, !!result);
        return result;
    }
    _buildQueryReturning(queryColumns, params, isOutermostQuery) {
        if (!queryColumns) {
            return '';
        }
        const columns = {};
        (0, SqlBuilder_1.flattenQueryColumns)(queryColumns, columns, '');
        let requireComma = false;
        let result = '';
        for (const property in columns) {
            if (requireComma) {
                result += ', ';
            }
            result += this._appendColumnValue(columns[property], params, isOutermostQuery);
            if (property) {
                result += ' as ' + this._appendColumnAlias(property, params);
            }
            requireComma = true;
        }
        if (!result) {
            return '';
        }
        return ' returning ' + result;
    }
    _buildInsertOnConflictBeforeInto(_query, _params) {
        return '';
    }
    _buildInsertOnConflictBeforeReturning(query, params) {
        if (!query.__onConflictDoNothing && !query.__onConflictUpdateSets) {
            return '';
        }
        let result = ' on conflict';
        const onConflictOnColumns = query.__onConflictOnColumns;
        if (onConflictOnColumns) {
            result += ' (';
            for (let i = 0, length = onConflictOnColumns.length; i < length; i++) {
                if (i > 0) {
                    result += ', ';
                }
                const column = onConflictOnColumns[i];
                result += this._appendSql(column, params);
            }
            result += ')';
            const where = query.__onConflictOnColumnsWhere;
            if (where) {
                result += ' where ';
                result += this._appendCondition(where, params);
            }
        }
        const constraint = query.__onConflictOnConstraint;
        if (constraint) {
            result += ' on constraint ';
            result += this._appendValue(constraint, params, 'string', 'string', undefined);
        }
        if (query.__onConflictDoNothing) {
            result += ' do nothing';
        }
        const oldSafeTableOrView = this._getSafeTableOrView(params);
        this._setSafeTableOrView(params, undefined);
        let columns = '';
        const table = query.__table;
        const shape = query.__onConflictUpdateShape;
        const sets = query.__onConflictUpdateSets;
        if (sets) {
            if (shape) { // Follow shape order
                const properties = Object.getOwnPropertyNames(shape);
                for (let i = 0, length = properties.length; i < length; i++) {
                    const property = properties[i];
                    const columnName = shape[property];
                    const column = (0, Column_2.__getColumnOfObject)(table, columnName);
                    if (!column) {
                        // Additional property provided in the value object
                        // Skipped because it is not part of the table
                        // This allows to have more complex objects used in the query
                        continue;
                    }
                    if (!(property in sets)) {
                        // No value set for that property in the shape
                        continue;
                    }
                    if (columns) {
                        columns += ', ';
                    }
                    const value = sets[property];
                    columns += this._appendColumnNameForUpdate(column, params);
                    columns += ' = ';
                    columns += this._appendValueForColumn(column, value, params);
                }
            }
            else { // No shape, follow set order
                const properties = Object.getOwnPropertyNames(sets);
                for (let i = 0, length = properties.length; i < length; i++) {
                    const property = properties[i];
                    const column = (0, Column_2.__getColumnOfObject)(table, property);
                    if (!column) {
                        // Additional property provided in the value object
                        // Skipped because it is not part of the table
                        // This allows to have more complex objects used in the query
                        continue;
                    }
                    if (columns) {
                        columns += ', ';
                    }
                    const value = sets[property];
                    columns += this._appendColumnNameForUpdate(column, params);
                    columns += ' = ';
                    columns += this._appendValueForColumn(column, value, params);
                }
            }
            if (!columns) {
                return '';
            }
            result += ' do update set ' + columns;
            const where = query.__onConflictUpdateWhere;
            if (where) {
                result += ' where ';
                result += this._appendCondition(where, params);
            }
        }
        this._setSafeTableOrView(params, oldSafeTableOrView);
        return result;
    }
    _nextSequenceValue(_params, sequenceName) {
        return "nextval('" + sequenceName + "')";
    }
    _currentSequenceValue(_params, sequenceName) {
        return "currval('" + sequenceName + "')";
    }
    _buildUpdate(query, params) {
        this._ensureRootQuery(query, params);
        const oldSafeTableOrView = this._getSafeTableOrView(params);
        const oldFakeNameOf = this._getFakeNamesOf(params);
        const table = query.__table;
        const sets = query.__sets;
        const customization = query.__customization;
        if (query.__froms || query.__joins) {
            this._setSafeTableOrView(params, undefined);
        }
        else {
            this._setSafeTableOrView(params, table);
        }
        const oldValues = query.__oldValues;
        const requiredTables = this._extractAdditionalRequiredTablesForUpdate(query, params);
        const requiredColumns = this._extractAdditionalRequiredColumnsForUpdate(query, requiredTables, params);
        this._setFakeNamesOf(params, requiredTables);
        let updateQuery = '';
        if (customization && customization.beforeQuery) {
            updateQuery += this._appendRawFragment(customization.beforeQuery, params) + ' ';
        }
        updateQuery += this._buildWith(query, params);
        updateQuery += 'update ';
        if (customization && customization.afterUpdateKeyword) {
            updateQuery += this._appendRawFragment(customization.afterUpdateKeyword, params) + ' ';
        }
        const oldForceAliasFor = this._getForceAliasFor(params);
        const oldForceAliasAs = this._getForceAliasAs(params);
        if (this._updateOldValueInFrom && query.__oldValues) {
            this._setForceAliasFor(params, query.__table);
            this._setForceAliasAs(params, this._updateNewAlias);
        }
        updateQuery += this._appendTableOrViewName(table, params);
        updateQuery += this._buildAfterUpdateTable(query, params);
        const shape = query.__shape;
        let columns = '';
        let updatePrimaryKey = false;
        if (shape) { // Follow shape order
            const properties = Object.getOwnPropertyNames(shape);
            for (let i = 0, length = properties.length; i < length; i++) {
                const property = properties[i];
                const shapePropertyValue = shape[property];
                let column;
                if (typeof shapePropertyValue === 'string') {
                    column = (0, Column_2.__getColumnOfObject)(table, shapePropertyValue);
                    if (!column) {
                        throw new Error('Unable to find the column "' + shapePropertyValue + '" in the table indicated in the provided shape property "' + shapePropertyValue + '"');
                    }
                }
                else {
                    column = shapePropertyValue;
                }
                if (!(0, Column_1.isColumn)(column)) {
                    // Additional property provided in the value object
                    // Skipped because it is not part of the table
                    // This allows to have more complex objects used in the query
                    continue;
                }
                if (!(property in sets)) {
                    // No value set for that property in the shape
                    continue;
                }
                const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
                updatePrimaryKey = updatePrimaryKey || columnPrivate.__isPrimaryKey;
                if (columns) {
                    columns += ', ';
                }
                const value = sets[property];
                columns += this._appendColumnNameForUpdate(column, params);
                columns += ' = ';
                columns += this._appendValueForColumn(column, value, params);
            }
        }
        else { // No shape, follow set order
            const properties = Object.getOwnPropertyNames(sets);
            for (let i = 0, length = properties.length; i < length; i++) {
                const property = properties[i];
                const column = (0, Column_2.__getColumnOfObject)(table, property);
                if (!column) {
                    // Additional property provided in the value object
                    // Skipped because it is not part of the table
                    // This allows to have more complex objects used in the query
                    continue;
                }
                const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
                updatePrimaryKey = updatePrimaryKey || columnPrivate.__isPrimaryKey;
                if (columns) {
                    columns += ', ';
                }
                const value = sets[property];
                columns += this._appendColumnNameForUpdate(column, params);
                columns += ' = ';
                columns += this._appendValueForColumn(column, value, params);
            }
        }
        updateQuery += ' set ' + columns;
        updateQuery += this._buildUpdateOutput(query, params);
        updateQuery += this._buildUpdateFrom(query, updatePrimaryKey, requiredTables, requiredColumns, params);
        if (oldValues && this._updateOldValueInFrom) {
            let where;
            for (let property in table) {
                const column = (0, Column_2.__getColumnOfObject)(table, property);
                if (!column) {
                    continue;
                }
                const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
                if (!columnPrivate.__isPrimaryKey) {
                    continue;
                }
                const oldCoumn = (0, values_1.__getValueSourceOfObject)(oldValues, property);
                if (!oldCoumn) {
                    throw new Error('The column ' + property + ' is missing from the old values table');
                }
                const condition = column.equals(oldCoumn);
                if (where) {
                    where = where.and(condition);
                }
                else {
                    where = condition;
                }
            }
            if (!where) {
                throw new Error('No primary key found');
            }
            const oldForceAliasFor = this._getForceAliasFor(params);
            const oldForceAliasAs = this._getForceAliasAs(params);
            this._setForceAliasFor(params, table);
            this._setForceAliasAs(params, this._updateNewAlias);
            const whereCondition = this._appendCondition(where, params);
            if (whereCondition) {
                updateQuery += ' where ' + whereCondition;
            }
            else if (!query.__allowNoWhere) {
                throw new Error('No where generated for link with the update old values');
            }
            this._setForceAliasFor(params, oldForceAliasFor);
            this._setForceAliasAs(params, oldForceAliasAs);
        }
        else if (query.__where) {
            const whereCondition = this._appendCondition(query.__where, params);
            if (whereCondition) {
                updateQuery += ' where ' + whereCondition;
            }
            else if (!query.__allowNoWhere) {
                throw new Error('No where defined for the update operation');
            }
        }
        else if (!query.__allowNoWhere) {
            throw new Error('No where defined for the update operation');
        }
        updateQuery += this._buildUpdateReturning(query, params);
        if (customization && customization.afterQuery) {
            updateQuery += ' ' + this._appendRawFragment(customization.afterQuery, params);
        }
        this._setForceAliasFor(params, oldForceAliasFor);
        this._setForceAliasAs(params, oldForceAliasAs);
        this._setSafeTableOrView(params, oldSafeTableOrView);
        this._setFakeNamesOf(params, oldFakeNameOf);
        this._resetRootQuery(query, params);
        return updateQuery;
    }
    _extractAdditionalRequiredTablesForUpdate(query, _params) {
        if (!this._updateOldValueInFrom || !query.__oldValues) {
            return undefined;
        }
        const froms = query.__froms;
        const joins = query.__joins;
        if ((!froms || froms.length < 0) && (!joins || joins.length < 0)) {
            return undefined;
        }
        const result = new Set();
        const sets = query.__sets;
        for (let property in sets) {
            (0, ITableOrView_1.__registerTableOrView)(sets[property], this, result);
        }
        const columns = query.__columns;
        if (columns) {
            for (let property in columns) {
                (0, ITableOrView_1.__registerTableOrView)(columns[property], this, result);
            }
        }
        result.delete(query.__table);
        result.delete(query.__oldValues);
        if (result.size <= 0) {
            return undefined;
        }
        return result;
    }
    _extractAdditionalRequiredColumnsForUpdate(query, requiredTables, _params) {
        if (!requiredTables) {
            return undefined;
        }
        const result = new Set();
        const sets = query.__sets;
        for (let property in sets) {
            (0, ITableOrView_1.__registerRequiredColumn)(sets[property], this, result, requiredTables);
        }
        const columns = query.__columns;
        if (columns) {
            for (let property in columns) {
                (0, ITableOrView_1.__registerRequiredColumn)(columns[property], this, result, requiredTables);
            }
        }
        if (result.size <= 0) {
            return undefined;
        }
        return result;
    }
    _appendColumnNameForUpdate(column, _params) {
        const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
        return this._escape(columnPrivate.__name, true);
    }
    _appendUpdateOldValueForUpdate(query, updatePrimaryKey, _requiredTables, _params) {
        const oldValues = query.__oldValues;
        if (!oldValues) {
            return '';
        }
        const oldValuesPrivate = (0, ITableOrView_2.__getTableOrViewPrivate)(oldValues);
        if (!oldValuesPrivate.__as) {
            throw new Error('No alias found for the old values to define the locking strategy');
        }
        let result;
        if (updatePrimaryKey) {
            result = ' for update of ' + this._escape(oldValuesPrivate.__as, true);
        }
        else {
            result = ' for no key update of ' + this._escape(oldValuesPrivate.__as, true);
        }
        return result;
    }
    _buildAfterUpdateTable(_query, _params) {
        return '';
    }
    _buildUpdateFrom(query, updatePrimaryKey, requiredTables, requiredColumns, params) {
        if (!this._updateOldValueInFrom) {
            const from = this._buildFromJoins(query.__froms, query.__joins, undefined, params);
            if (from) {
                return ' from ' + from;
            }
            return '';
        }
        const oldValues = query.__oldValues;
        if (!oldValues) {
            const from = this._buildFromJoins(query.__froms, query.__joins, undefined, params);
            if (from) {
                return ' from ' + from;
            }
            return '';
        }
        let from = ' from ';
        const oldValuesPrivate = (0, ITableOrView_2.__getTableOrViewPrivate)(oldValues);
        if (!oldValuesPrivate.__as) {
            throw new Error('No alias found for the old values');
        }
        const oldForceAliasFor = this._getForceAliasFor(params);
        const oldForceAliasAs = this._getForceAliasAs(params);
        const oldFakeNameOf = this._getFakeNamesOf(params);
        this._setFakeNamesOf(params, undefined);
        this._setForceAliasFor(params, query.__table);
        this._setForceAliasAs(params, oldValuesPrivate.__as);
        from += '(select ' + this._escape(oldValuesPrivate.__as, true) + '.*';
        if (requiredColumns) {
            const additionalColumns = Array.from(requiredColumns).sort((c1, c2) => {
                const c1Private = (0, Column_2.__getColumnPrivate)(c1);
                const c2Private = (0, Column_2.__getColumnPrivate)(c2);
                const t1 = c1Private.__tableOrView;
                const t2 = c2Private.__tableOrView;
                const t1Private = (0, ITableOrView_2.__getTableOrViewPrivate)(t1);
                const t1Name = t1Private.__as || t1Private.__name;
                const t2Private = (0, ITableOrView_2.__getTableOrViewPrivate)(t2);
                const t2Name = t2Private.__as || t2Private.__name;
                if (t1Name > t2Name) {
                    return 1;
                }
                if (t1Name < t2Name) {
                    return -1;
                }
                if (c1Private.__name > c2Private.__name) {
                    return 1;
                }
                if (c1Private.__name < c2Private.__name) {
                    return -1;
                }
                return 0;
            });
            for (let i = 0, length = additionalColumns.length; i < length; i++) {
                const column = additionalColumns[i];
                from += ', ';
                from += this._appendSql(column, params);
                from += ' as ';
                const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
                const tablePrivate = (0, ITableOrView_2.__getTableOrViewPrivate)(columnPrivate.__tableOrView);
                if (tablePrivate.__as) {
                    from += this._escape(tablePrivate.__as + '__' + columnPrivate.__name, true);
                }
                else {
                    from += this._escape(tablePrivate.__name + '__' + columnPrivate.__name, true);
                }
            }
        }
        from += ' from ';
        from += this._appendTableOrViewName(oldValues, params);
        const innerFrom = this._buildFromJoins(query.__froms, query.__joins, undefined, params);
        if (innerFrom) {
            from = from + ', ' + innerFrom;
        }
        if (query.__where) {
            const whereCondition = this._appendCondition(query.__where, params);
            if (whereCondition) {
                from += ' where ' + whereCondition;
            }
            else if (!query.__allowNoWhere) {
                throw new Error('No where defined for the update operation');
            }
        }
        else if (!query.__allowNoWhere) {
            throw new Error('No where defined for the update operation');
        }
        from += this._appendUpdateOldValueForUpdate(query, updatePrimaryKey, requiredTables, params);
        from += ')';
        if (this._supportTableAliasWithAs) {
            from += ' as ';
        }
        else {
            from += ' ';
        }
        from += this._escape(oldValuesPrivate.__as, true);
        this._setForceAliasFor(params, oldForceAliasFor);
        this._setForceAliasAs(params, oldForceAliasAs);
        this._setFakeNamesOf(params, oldFakeNameOf);
        return from;
    }
    _buildUpdateOutput(_query, _params) {
        return '';
    }
    _buildUpdateReturning(query, params) {
        const isOutermostQuery = this._isCurrentRootQuery(query, params);
        return this._buildQueryReturning(query.__columns, params, isOutermostQuery);
    }
    _buildDelete(query, params) {
        this._ensureRootQuery(query, params);
        const oldFakeNameOf = this._getFakeNamesOf(params);
        this._setFakeNamesOf(params, undefined);
        const oldSafeTableOrView = this._getSafeTableOrView(params);
        const table = query.__table;
        const customization = query.__customization;
        if (query.__using || query.__joins) {
            this._setSafeTableOrView(params, undefined);
        }
        else {
            this._setSafeTableOrView(params, table);
        }
        let deleteQuery = '';
        if (customization && customization.beforeQuery) {
            deleteQuery += this._appendRawFragment(customization.beforeQuery, params) + ' ';
        }
        deleteQuery += this._buildWith(query, params);
        deleteQuery += 'delete ';
        if (customization && customization.afterDeleteKeyword) {
            deleteQuery += this._appendRawFragment(customization.afterDeleteKeyword, params) + ' ';
        }
        deleteQuery += 'from ';
        deleteQuery += this._appendTableOrViewName(table, params);
        deleteQuery += this._buildDeleteOutput(query, params);
        deleteQuery += this._buidDeleteUsing(query, params);
        if (query.__where) {
            const whereCondition = this._appendCondition(query.__where, params);
            if (whereCondition) {
                deleteQuery += ' where ' + whereCondition;
            }
            else if (!query.__allowNoWhere) {
                throw new Error('No where defined for the delete operation');
            }
        }
        else if (!query.__allowNoWhere) {
            throw new Error('No where defined for the delete operation');
        }
        deleteQuery += this._buildDeleteReturning(query, params);
        if (customization && customization.afterQuery) {
            deleteQuery += ' ' + this._appendRawFragment(customization.afterQuery, params);
        }
        this._setSafeTableOrView(params, oldSafeTableOrView);
        this._setFakeNamesOf(params, oldFakeNameOf);
        this._resetRootQuery(query, params);
        return deleteQuery;
    }
    _buidDeleteUsing(query, params) {
        const result = this._buildFromJoins(query.__using, query.__joins, undefined, params);
        if (result) {
            return ' using ' + result;
        }
        return '';
    }
    _buildDeleteOutput(_query, _params) {
        return '';
    }
    _buildDeleteReturning(query, params) {
        const isOutermostQuery = this._isCurrentRootQuery(query, params);
        return this._buildQueryReturning(query.__columns, params, isOutermostQuery);
    }
    /*
     * Comparators
     */
    // SqlComparator0
    _isNull(params, valueSource) {
        return this._appendSqlParenthesis(valueSource, params) + ' is null';
    }
    _isNotNull(params, valueSource) {
        return this._appendSqlParenthesis(valueSource, params) + ' is not null';
    }
    _hasSameBooleanTypeAdapter(valueSource, value) {
        if ((0, Column_1.isColumn)(valueSource) && (0, Column_1.isColumn)(value)) {
            const valueSourcePrivate = (0, Column_2.__getColumnPrivate)(valueSource);
            const valuePrivate = (0, Column_2.__getColumnPrivate)(value);
            if ((0, values_1.__isBooleanValueSource)(valueSourcePrivate) && (0, values_1.__isBooleanValueSource)(valuePrivate)) {
                const valueSourceTypeAdapter = valueSourcePrivate.__typeAdapter;
                const valueTypeAdapter = valuePrivate.__typeAdapter;
                if (valueSourceTypeAdapter instanceof TypeAdapter_1.CustomBooleanTypeAdapter && valueTypeAdapter instanceof TypeAdapter_1.CustomBooleanTypeAdapter) {
                    return valueSourceTypeAdapter.trueValue === valueTypeAdapter.trueValue && valueSourceTypeAdapter.falseValue === valueTypeAdapter.falseValue;
                }
            }
        }
        return false;
    }
    // SqlComparator1
    _equals(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        if ((0, Column_1.isColumn)(valueSource) && (0, Column_1.isColumn)(value) && this._hasSameBooleanTypeAdapter(valueSource, value)) {
            return this._appendRawColumnName(valueSource, params) + ' = ' + this._appendRawColumnName(value, params);
        }
        return this._appendSqlParenthesis(valueSource, params) + ' = ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter);
    }
    _notEquals(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        if ((0, Column_1.isColumn)(valueSource) && (0, Column_1.isColumn)(value) && this._hasSameBooleanTypeAdapter(valueSource, value)) {
            return this._appendRawColumnName(valueSource, params) + ' <> ' + this._appendRawColumnName(value, params);
        }
        return this._appendSqlParenthesis(valueSource, params) + ' <> ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter);
    }
    _is(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        if ((0, Column_1.isColumn)(valueSource) && (0, Column_1.isColumn)(value) && this._hasSameBooleanTypeAdapter(valueSource, value)) {
            return this._appendRawColumnName(valueSource, params) + ' is not distinct from ' + this._appendRawColumnName(value, params);
        }
        return this._appendSqlParenthesis(valueSource, params) + ' is not distinct from ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter);
    }
    _isNot(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        if ((0, Column_1.isColumn)(valueSource) && (0, Column_1.isColumn)(value) && this._hasSameBooleanTypeAdapter(valueSource, value)) {
            return this._appendRawColumnName(valueSource, params) + ' is distinct from ' + this._appendRawColumnName(value, params);
        }
        return this._appendSqlParenthesis(valueSource, params) + ' is distinct from ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter);
    }
    _equalsInsensitive(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' = ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter) + ' collate ' + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + ' = ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter);
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ') = lower(' + this._appendValue(value, params, columnType, columnTypeName, typeAdapter) + ')';
        }
    }
    _notEqualsInsensitive(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' <> ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter) + ' collate ' + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + ' <> ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter);
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ') <> lower(' + this._appendValue(value, params, columnType, columnTypeName, typeAdapter) + ')';
        }
    }
    _lessThan(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' < ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter);
    }
    _greaterThan(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' > ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter);
    }
    _lessOrEquals(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' <= ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter);
    }
    _greaterOrEquals(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' >= ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter);
    }
    _in(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' in ' + this._appendSpreadValue(value, params, columnType, columnTypeName, typeAdapter);
    }
    _notIn(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' not in ' + this._appendSpreadValue(value, params, columnType, columnTypeName, typeAdapter);
    }
    _like(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' like ' + this._appendValue(value, params, columnType, columnTypeName, typeAdapter);
    }
    _notLike(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' not like ' + this._appendValue(value, params, columnType, columnTypeName, typeAdapter);
    }
    _likeInsensitive(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' like ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter) + ' collate ' + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + ' like ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter);
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ') like lower(' + this._appendValue(value, params, columnType, columnTypeName, typeAdapter) + ')';
        }
    }
    _notLikeInsensitive(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' not like ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter) + ' collate ' + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + ' not like ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter);
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ') not like lower(' + this._appendValue(value, params, columnType, columnTypeName, typeAdapter) + ')';
        }
    }
    _startsWith(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' like (' + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + " || '%')";
    }
    _notStartsWith(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' not like (' + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + " || '%')";
    }
    _endsWith(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + " like ('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + ')';
    }
    _notEndsWith(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + " not like ('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + ')';
    }
    _startsWithInsensitive(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' like (' + this._escapeLikeWildcard(value, params, columnType, columnTypeName, typeAdapter) + " || '%') collate " + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + ' like (' + this._escapeLikeWildcard(value, params, columnType, columnTypeName, typeAdapter) + " || '%')";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ') like lower(' + this._escapeLikeWildcard(value, params, columnType, columnTypeName, typeAdapter) + " || '%')";
        }
    }
    _notStartsWithInsensitive(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' not like (' + this._escapeLikeWildcard(value, params, columnType, columnTypeName, typeAdapter) + " || '%') collate " + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + ' not like (' + this._escapeLikeWildcard(value, params, columnType, columnTypeName, typeAdapter) + " || '%')";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ') not like lower(' + this._escapeLikeWildcard(value, params, columnType, columnTypeName, typeAdapter) + " || '%')";
        }
    }
    _endsWithInsensitive(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " like ('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + ') collate ' + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + " like ('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + ')';
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ") like lower('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + ')';
        }
    }
    _notEndsWithInsensitive(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " not like ('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + ') collate ' + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + " not like ('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + ')';
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ") not like lower('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + ')';
        }
    }
    _contains(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + " like ('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + " || '%')";
    }
    _notContains(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + " not like ('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + " || '%')";
    }
    _containsInsensitive(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " like ('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + " || '%') collate " + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + " like ('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + " || '%')";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ") like lower('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + " || '%')";
        }
    }
    _notContainsInsensitive(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " not like ('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + " || '%') collate " + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + " not like ('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + " || '%')";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ") not like lower('%' || " + this._escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) + " || '%')";
        }
    }
    // SqlComparator2
    _between(params, valueSource, value, value2, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' between ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter) + ' and ' + this._appendValueParenthesis(value2, params, columnType, columnTypeName, typeAdapter);
    }
    _notBetween(params, valueSource, value, value2, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' not between ' + this._appendValueParenthesis(value, params, columnType, columnTypeName, typeAdapter) + ' and ' + this._appendValueParenthesis(value2, params, columnType, columnTypeName, typeAdapter);
    }
    // SqlOperationStatic0
    _pi(_params) {
        return 'pi()';
    }
    _random(_params) {
        return 'random()';
    }
    _currentDate(_params) {
        return 'current_date';
    }
    _currentTime(_params) {
        return 'current_time';
    }
    _currentTimestamp(_params) {
        return 'current_timestamp';
    }
    _default(_params) {
        return 'default';
    }
    _true(_params) {
        return this._trueValue;
    }
    _trueForCondition(_params) {
        return this._trueValueForCondition;
    }
    _false(_params) {
        return this._falseValue;
    }
    _falseForCondition(_params) {
        return this._falseValueForCondition;
    }
    // SqlOperationStatic01
    _const(params, value, columnType, columnTypeName, typeAdapter) {
        return this._appendValue(value, params, columnType, columnTypeName, typeAdapter);
    }
    _constForCondition(params, value, columnType, columnTypeName, typeAdapter) {
        return this._appendConditionValue(value, params, columnType, columnTypeName, typeAdapter);
    }
    _exists(params, value, columnType, columnTypeName, typeAdapter) {
        return 'exists(' + this._appendValue(value, params, columnType, columnTypeName, typeAdapter) + ')';
    }
    _notExists(params, value, columnType, columnTypeName, typeAdapter) {
        return 'not exists(' + this._appendValue(value, params, columnType, columnTypeName, typeAdapter) + ')';
    }
    _escapeLikeWildcard(params, value, columnType, columnTypeName, typeAdapter) {
        if (typeof value === 'string') {
            value = value.replace(/\\/g, '\\\\');
            value = value.replace(/%/g, '\\%');
            value = value.replace(/_/g, '\\_');
            return this._appendValue(value, params, columnType, columnTypeName, typeAdapter);
        }
        else {
            return "replace(replace(replace(" + this._appendValue(value, params, columnType, columnTypeName, typeAdapter) + ", '\\', '\\\\'), '%', '\\%'), '_', '\\_')";
        }
    }
    // SqlFunction0
    _negate(params, valueSource) {
        const sql = this._appendConditionSql(valueSource, params);
        if (!sql) {
            return sql;
        }
        if (sql === this._trueValueForCondition) {
            return this._falseValueForCondition;
        }
        else if (sql === this._falseValueForCondition) {
            return this._trueValueForCondition;
        }
        if (this._needParenthesis(valueSource)) {
            return 'not (' + sql + ')';
        }
        return 'not ' + sql;
    }
    _toLowerCase(params, valueSource) {
        return 'lower(' + this._appendSql(valueSource, params) + ')';
    }
    _toUpperCase(params, valueSource) {
        return 'upper(' + this._appendSql(valueSource, params) + ')';
    }
    _length(params, valueSource) {
        return 'length(' + this._appendSql(valueSource, params) + ')';
    }
    _trim(params, valueSource) {
        return 'trim(' + this._appendSql(valueSource, params) + ')';
    }
    _trimLeft(params, valueSource) {
        return 'ltrim(' + this._appendSql(valueSource, params) + ')';
    }
    _trimRight(params, valueSource) {
        return 'rtrim(' + this._appendSql(valueSource, params) + ')';
    }
    _reverse(params, valueSource) {
        return 'reverse(' + this._appendSql(valueSource, params) + ')';
    }
    _asDouble(params, valueSource) {
        return 'cast(' + this._appendSql(valueSource, params) + 'as double presition)';
    }
    _abs(params, valueSource) {
        return 'abs(' + this._appendSql(valueSource, params) + ')';
    }
    _ceil(params, valueSource) {
        return 'ceil(' + this._appendSql(valueSource, params) + ')';
    }
    _floor(params, valueSource) {
        return 'floor(' + this._appendSql(valueSource, params) + ')';
    }
    _round(params, valueSource) {
        return 'round(' + this._appendSql(valueSource, params) + ')';
    }
    _exp(params, valueSource) {
        return 'exp(' + this._appendSql(valueSource, params) + ')';
    }
    _ln(params, valueSource) {
        return 'ln(' + this._appendSql(valueSource, params) + ')';
    }
    _log10(params, valueSource) {
        return 'log(' + this._appendSql(valueSource, params) + ')';
    }
    _sqrt(params, valueSource) {
        return 'sqrt(' + this._appendSql(valueSource, params) + ')';
    }
    _cbrt(params, valueSource) {
        return 'cbrt(' + this._appendSql(valueSource, params) + ')';
    }
    _sign(params, valueSource) {
        return 'sign(' + this._appendSql(valueSource, params) + ')';
    }
    _acos(params, valueSource) {
        return 'acos(' + this._appendSql(valueSource, params) + ')';
    }
    _asin(params, valueSource) {
        return 'asin(' + this._appendSql(valueSource, params) + ')';
    }
    _atan(params, valueSource) {
        return 'atan(' + this._appendSql(valueSource, params) + ')';
    }
    _cos(params, valueSource) {
        return 'cos(' + this._appendSql(valueSource, params) + ')';
    }
    _cot(params, valueSource) {
        return 'cot(' + this._appendSql(valueSource, params) + ')';
    }
    _sin(params, valueSource) {
        return 'sin(' + this._appendSql(valueSource, params) + ')';
    }
    _tan(params, valueSource) {
        return 'tan(' + this._appendSql(valueSource, params) + ')';
    }
    _getDate(params, valueSource) {
        return 'extract(day from ' + this._appendSql(valueSource, params) + ')';
    }
    _getTime(params, valueSource) {
        return 'extract(epoch from ' + this._appendSql(valueSource, params) + ')';
    }
    _getFullYear(params, valueSource) {
        return 'extract(year from ' + this._appendSql(valueSource, params) + ')';
    }
    _getMonth(params, valueSource) {
        return 'extract(month from ' + this._appendSql(valueSource, params) + ')';
    }
    _getDay(params, valueSource) {
        return 'extract(dow from ' + this._appendSql(valueSource, params) + ')';
    }
    _getHours(params, valueSource) {
        return 'extract(hour from ' + this._appendSql(valueSource, params) + ')';
    }
    _getMinutes(params, valueSource) {
        return 'extract(minute from ' + this._appendSql(valueSource, params) + ')';
    }
    _getSeconds(params, valueSource) {
        return 'extract(second from ' + this._appendSql(valueSource, params) + ')';
    }
    _getMilliseconds(params, valueSource) {
        return 'extract(millisecond from ' + this._appendSql(valueSource, params) + ')';
    }
    _asString(params, valueSource) {
        // Transform an uuid to string
        return this._appendSqlParenthesis(valueSource, params);
    }
    _asNullValue(_params, _columnType, columnTypeName, typeAdapter) {
        if (typeAdapter && typeAdapter.transformPlaceholder) {
            return typeAdapter.transformPlaceholder('null', columnTypeName, false, null, this._defaultTypeAdapter);
        }
        else {
            return this._defaultTypeAdapter.transformPlaceholder('null', columnTypeName, false, null);
        }
    }
    // Oracle recursive
    _prior(params, valueSource) {
        return 'prior ' + this._appendSql(valueSource, params);
    }
    // SqlFunction1
    _valueWhenNull(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return 'coalesce(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, columnType, columnTypeName, typeAdapter) + ')';
    }
    _nullIfValue(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return 'nullif(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, columnType, columnTypeName, typeAdapter) + ')';
    }
    _and(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        this._setResultingOperation(params, undefined);
        const sql = this._appendConditionSql(valueSource, params);
        const op = this._getResultingOperation(params);
        this._setResultingOperation(params, undefined);
        const sql2 = this._appendConditionValue(value, params, columnType, columnTypeName, typeAdapter);
        const op2 = this._getResultingOperation(params);
        this._setResultingOperation(params, undefined);
        if (!sql || sql === this._trueValueForCondition) {
            // sql === this._trueValueForCondition reduce unnecesary ands allowing dynamic queries
            this._setResultingOperation(params, op2);
            return sql2;
        }
        else if (!sql2 || sql2 === this._trueValueForCondition) {
            // sql2 === this._trueValueForCondition reduce unnecesary ands allowing dynamic queries
            this._setResultingOperation(params, op);
            return sql;
        }
        else {
            let result;
            if (op === '_or') {
                result = '(' + sql + ')';
            }
            else {
                result = sql;
            }
            result += ' and ';
            if (op2 === '_or') {
                result += '(' + sql2 + ')';
            }
            else {
                result += sql2;
            }
            this._setResultingOperation(params, '_and');
            return result;
        }
    }
    _or(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        this._setResultingOperation(params, undefined);
        const sql = this._appendConditionSql(valueSource, params);
        const op = this._getResultingOperation(params);
        this._setResultingOperation(params, undefined);
        const sql2 = this._appendConditionValue(value, params, columnType, columnTypeName, typeAdapter);
        const op2 = this._getResultingOperation(params);
        this._setResultingOperation(params, undefined);
        if (!sql || sql === this._falseValueForCondition) {
            // !sql || sql === this._falseValueForCondition reduce unnecesary ors allowing dynamic queries
            this._setResultingOperation(params, op2);
            return sql2;
        }
        else if (!sql2 || sql2 === this._falseValueForCondition) {
            // !sql2 || sql2 === this._falseValueForCondition reduce unnecesary ors allowing dynamic queries
            this._setResultingOperation(params, op);
            return sql;
        }
        else {
            let result;
            if (op === '_and') {
                result = '(' + sql + ')';
            }
            else {
                result = sql;
            }
            result += ' or ';
            if (op2 === '_and') {
                result += '(' + sql2 + ')';
            }
            else {
                result += sql2;
            }
            this._setResultingOperation(params, '_or');
            return result;
        }
    }
    _concat(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesisExcluding(valueSource, params, '_concat') + ' || ' + this._appendValueParenthesisExcluding(value, params, columnType, columnTypeName, typeAdapter, '_concat');
    }
    _substrToEnd(params, valueSource, value, _columnType, _columnTypeName, typeAdapter) {
        if (typeof value === 'number') {
            return 'substr(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value + 1, params, 'int', 'int', typeAdapter) + ')';
        }
        else {
            return 'substr(' + this._appendSql(valueSource, params) + ', ' + this._appendValueParenthesis(value, params, 'int', 'int', typeAdapter) + ' + 1)';
        }
    }
    _substringToEnd(params, valueSource, value, _columnType, _columnTypeName, typeAdapter) {
        if (typeof value === 'number') {
            return 'substr(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value + 1, params, 'int', 'int', typeAdapter) + ')';
        }
        else {
            return 'substr(' + this._appendSql(valueSource, params) + ', ' + this._appendValueParenthesis(value, params, 'int', 'int', typeAdapter) + ' + 1)';
        }
    }
    _getMathArgumentType(columnType, _columnTypeName, value) {
        if (columnType === 'customInt' || columnType === 'customDouble') {
            return columnType;
        }
        if (typeof value === 'number') {
            if (!Number.isInteger(value)) {
                if (columnType === 'stringInt' || columnType === 'stringDouble') {
                    return 'stringDouble';
                }
                return 'double';
            }
            if (columnType === 'stringInt' || columnType === 'stringDouble') {
                return 'stringInt';
            }
            return 'int';
        }
        if (typeof value === 'bigint') {
            return 'bigint';
        }
        if (typeof value === 'string') {
            if (value.indexOf('.') >= 0) {
                return 'stringDouble';
            }
            return 'stringInt';
        }
        return columnType;
    }
    _getMathArgumentTypeName(columnType, columnTypeName, value) {
        if (columnType === 'customInt' || columnType === 'customDouble') {
            return columnTypeName;
        }
        if (typeof value === 'number') {
            if (!Number.isInteger(value)) {
                if (columnType === 'stringInt' || columnType === 'stringDouble') {
                    return 'stringDouble';
                }
                return 'double';
            }
            if (columnType === 'stringInt' || columnType === 'stringDouble') {
                return 'stringInt';
            }
            return 'int';
        }
        if (typeof value === 'bigint') {
            return 'bigint';
        }
        if (typeof value === 'string') {
            if (value.indexOf('.') >= 0) {
                return 'stringDouble';
            }
            return 'stringInt';
        }
        return columnTypeName;
    }
    _power(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return 'power(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, this._getMathArgumentType(columnType, columnTypeName, value), this._getMathArgumentTypeName(columnType, columnTypeName, value), typeAdapter) + ')';
    }
    _logn(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return 'log(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, this._getMathArgumentType(columnType, columnTypeName, value), this._getMathArgumentTypeName(columnType, columnTypeName, value), typeAdapter) + ')';
    }
    _roundn(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return 'round(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, this._getMathArgumentType(columnType, columnTypeName, value), this._getMathArgumentTypeName(columnType, columnTypeName, value), typeAdapter) + ')';
    }
    _minimumBetweenTwoValues(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return 'least(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, this._getMathArgumentType(columnType, columnTypeName, value), this._getMathArgumentTypeName(columnType, columnTypeName, value), typeAdapter) + ')';
    }
    _maximumBetweenTwoValues(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return 'greatest(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, this._getMathArgumentType(columnType, columnTypeName, value), this._getMathArgumentTypeName(columnType, columnTypeName, value), typeAdapter) + ')';
    }
    _add(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesisExcluding(valueSource, params, '_add') + ' + ' + this._appendValueParenthesisExcluding(value, params, this._getMathArgumentType(columnType, columnTypeName, value), this._getMathArgumentTypeName(columnType, columnTypeName, value), typeAdapter, '_add');
    }
    _substract(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesisExcluding(valueSource, params, '_substract') + ' - ' + this._appendValueParenthesis(value, params, this._getMathArgumentType(columnType, columnTypeName, value), this._getMathArgumentTypeName(columnType, columnTypeName, value), typeAdapter);
    }
    _multiply(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesisExcluding(valueSource, params, '_multiply') + ' * ' + this._appendValueParenthesisExcluding(value, params, this._getMathArgumentType(columnType, columnTypeName, value), this._getMathArgumentTypeName(columnType, columnTypeName, value), typeAdapter, '_multiply');
    }
    _divide(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return 'cast(' + this._appendSql(valueSource, params) + ' as double presition) / cast(' + this._appendValue(value, params, this._getMathArgumentType(columnType, columnTypeName, value), this._getMathArgumentTypeName(columnType, columnTypeName, value), typeAdapter) + ' as double presition)';
    }
    _modulo(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' % ' + this._appendValueParenthesis(value, params, this._getMathArgumentType(columnType, columnTypeName, value), this._getMathArgumentTypeName(columnType, columnTypeName, value), typeAdapter);
    }
    _atan2(params, valueSource, value, columnType, columnTypeName, typeAdapter) {
        return 'atan2(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, this._getMathArgumentType(columnType, columnTypeName, value), this._getMathArgumentTypeName(columnType, columnTypeName, value), typeAdapter) + ')';
    }
    // SqlFunction2
    _substr(params, valueSource, value, value2, _columnType, _columnTypeName, typeAdapter) {
        if (typeof value === 'number') {
            return 'substr(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value + 1, params, 'int', 'int', typeAdapter) + ', ' + this._appendValue(value2, params, 'int', 'int', typeAdapter) + ')';
        }
        else {
            return 'substr(' + this._appendSql(valueSource, params) + ', ' + this._appendValueParenthesis(value, params, 'int', 'int', typeAdapter) + ' + 1, ' + this._appendValue(value2, params, 'int', 'int', typeAdapter) + ')';
        }
    }
    _substring(params, valueSource, value, value2, _columnType, _columnTypeName, typeAdapter) {
        if (typeof value === 'number' && typeof value2 === 'number') {
            const count = value2 - value;
            return 'substr(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value + 1, params, 'int', 'int', typeAdapter) + ', ' + this._appendValue(count, params, 'int', 'int', typeAdapter) + ')';
        }
        if (typeof value === 'number') {
            return 'substr(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value + 1, params, 'int', 'int', typeAdapter) + ', ' + this._appendValue(value2, params, 'int', 'int', typeAdapter) + ' - ' + this._appendValue(value, params, 'int', 'int', typeAdapter) + ')';
        }
        else {
            return 'substr(' + this._appendSql(valueSource, params) + ', ' + this._appendValueParenthesis(value, params, 'int', 'int', typeAdapter) + ' + 1, ' + this._appendValue(value2, params, 'int', 'int', typeAdapter) + ' - ' + this._appendValue(value, params, 'int', 'int', typeAdapter) + ')';
        }
    }
    _replaceAll(params, valueSource, value, value2, columnType, columnTypeName, typeAdapter) {
        return 'replace(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, columnType, columnTypeName, typeAdapter) + ', ' + this._appendValue(value2, params, columnType, columnTypeName, typeAdapter) + ')';
    }
    _buildCallProcedure(params, procedureName, procedureParams) {
        let result = 'call ' + this._escape(procedureName, false) + '(';
        if (procedureParams.length > 0) {
            result += this._appendSql(procedureParams[0], params);
            for (let i = 1, length = procedureParams.length; i < length; i++) {
                result += ', ' + this._appendSql(procedureParams[i], params);
            }
        }
        return result + ')';
    }
    _buildCallFunction(params, functionName, functionParams) {
        let result = 'select ' + this._escape(functionName, false) + '(';
        if (functionParams.length > 0) {
            result += this._appendSql(functionParams[0], params);
            for (let i = 1, length = functionParams.length; i < length; i++) {
                result += ', ' + this._appendSql(functionParams[i], params);
            }
        }
        return result + ')';
    }
    _fragment(params, sql, sqlParams) {
        if (sqlParams.length <= 0) {
            return sql[0];
        }
        let result = '';
        for (let i = 0, length = sqlParams.length; i < length; i++) {
            result += sql[i];
            result += this._appendConditionSql(sqlParams[i], params);
        }
        result += sql[sql.length - 1];
        return result;
    }
    _rawFragment(params, sql, sqlParams) {
        if (sqlParams.length <= 0) {
            return sql[0];
        }
        let result = '';
        for (let i = 0, length = sqlParams.length; i < length; i++) {
            result += sql[i];
            result += this._appendSql(sqlParams[i], params);
        }
        result += sql[sql.length - 1];
        return result;
    }
    _rawFragmentTableName(params, tableOrView) {
        return this._appendTableOrViewNameForFrom(tableOrView, params);
    }
    _rawFragmentTableAlias(params, tableOrView) {
        const forceAliasFor = this._getForceAliasFor(params);
        const forceAliasAs = this._getForceAliasAs(params);
        const as = (0, ITableOrView_2.__getTableOrViewPrivate)(tableOrView).__as;
        if (forceAliasFor === tableOrView && forceAliasAs) {
            return 'as ' + this._escape(forceAliasAs, true);
        }
        else if (as) {
            return 'as ' + this._escape(as, true);
        }
        return '';
    }
    _countAll(_params) {
        return 'count(*)';
    }
    _count(params, value) {
        return 'count(' + this._appendSql(value, params) + ')';
    }
    _countDistinct(params, value) {
        return 'count(distinct ' + this._appendSql(value, params) + ')';
    }
    _max(params, value) {
        return 'max(' + this._appendSql(value, params) + ')';
    }
    _min(params, value) {
        return 'min(' + this._appendSql(value, params) + ')';
    }
    _sum(params, value) {
        return 'sum(' + this._appendSql(value, params) + ')';
    }
    _sumDistinct(params, value) {
        return 'sum(distinct ' + this._appendSql(value, params) + ')';
    }
    _average(params, value) {
        return 'avg(' + this._appendSql(value, params) + ')';
    }
    _averageDistinct(params, value) {
        return 'avg(distinct ' + this._appendSql(value, params) + ')';
    }
    _stringConcat(params, separator, value) {
        if (separator === undefined || separator === null) {
            return 'string_concat(' + this._appendSql(value, params) + ')';
        }
        else if (separator === '') {
            return 'string_concat(' + this._appendSql(value, params) + ", '')";
        }
        else {
            return 'string_concat(' + this._appendSql(value, params) + ', ' + this._appendValue(separator, params, 'string', 'string', undefined) + ')';
        }
    }
    _stringConcatDistinct(params, separator, value) {
        if (separator === undefined || separator === null) {
            return 'string_concat(distinct ' + this._appendSql(value, params) + ')';
        }
        else if (separator === '') {
            return 'string_concat(distinct ' + this._appendSql(value, params) + ", '')";
        }
        else {
            return 'string_concat(distinct ' + this._appendSql(value, params) + ', ' + this._appendValue(separator, params, 'string', 'string', undefined) + ')';
        }
    }
    _aggregateValueAsArray(valueSource, params) {
        const valueSourcePrivate = (0, values_2.__getValueSourcePrivate)(valueSource);
        const aggregatedArrayColumns = valueSourcePrivate.__aggregatedArrayColumns;
        const aggregatedArrayDistinct = valueSourcePrivate.__aggregatedArrayDistinct;
        return this._appendAggragateArrayColumns(aggregatedArrayColumns, aggregatedArrayDistinct, params, undefined);
    }
    _needAgggregateArrayColumnsTransformation(query, _params) {
        return !!query.__asInlineAggregatedArrayValue;
    }
    _needAgggregateArrayWrapper(query, _params) {
        if (!query.__asInlineAggregatedArrayValue) {
            return false;
        }
        if (query.__type === 'compound') {
            return true;
        }
        if (query.__distinct) {
            return true;
        }
        if (query.__groupBy.length > 0) {
            return true;
        }
        if (query.__having) {
            return true;
        }
        if (!this._supportOrderByWhenAggregateArray) {
            if (query.__orderBy || query.__customization?.beforeOrderByItems || query.__customization?.afterOrderByItems) {
                return true;
            }
        }
        if (!this._supportLimitWhenAggregateArray) {
            if (query.__limit !== undefined) {
                return true;
            }
            if (query.__offset !== undefined) {
                return true;
            }
        }
        return false;
    }
    _buildSelectAsAggregatedArray(_query, _params) {
        return '';
    }
    _appendAggragateArrayWrapperBegin(query, params, aggregateId) {
        let aggregatedArrayColumns;
        if (query.__oneColumn) {
            aggregatedArrayColumns = query.__columns['result'];
            if (!aggregatedArrayColumns) {
                throw new Error('Illegal state: result column for a select one column not found');
            }
        }
        else {
            aggregatedArrayColumns = query.__columns;
        }
        return 'select ' + this._appendAggragateArrayWrappedColumns(aggregatedArrayColumns, params, aggregateId) + ' from (';
    }
    _appendAggragateArrayWrapperEnd(_query, _params, aggregateId) {
        let result = ')';
        if (this._supportTableAliasWithAs) {
            result += ' as ';
        }
        else {
            result += ' ';
        }
        result += 'a_' + aggregateId + '_';
        return result;
    }
    _appendAggragateArrayColumns(aggregatedArrayColumns, aggregatedArrayDistinct, params, _query) {
        const distict = aggregatedArrayDistinct ? 'distinct ' : '';
        if ((0, values_1.isValueSource)(aggregatedArrayColumns)) {
            return 'json_agg(' + distict + this._appendSql(aggregatedArrayColumns, params) + ')';
        }
        else {
            const columns = {};
            (0, SqlBuilder_1.flattenQueryColumns)(aggregatedArrayColumns, columns, '');
            let result = '';
            for (let prop in columns) {
                if (result) {
                    result += ', ';
                }
                result += "'" + prop + "', " + this._appendSql(columns[prop], params);
            }
            return 'json_agg(' + distict + 'json_build_object(' + result + '))';
        }
    }
    _appendAggragateArrayWrappedColumns(aggregatedArrayColumns, _params, aggregateId) {
        if ((0, values_1.isValueSource)(aggregatedArrayColumns)) {
            return 'json_agg(a_' + aggregateId + '_.result)';
        }
        else {
            const columns = {};
            (0, SqlBuilder_1.flattenQueryColumns)(aggregatedArrayColumns, columns, '');
            let result = '';
            for (let prop in columns) {
                if (result) {
                    result += ', ';
                }
                result += "'" + prop + "', a_" + aggregateId + "_." + this._escape(prop, true);
            }
            return 'json_agg(json_build_object(' + result + '))';
        }
    }
}
exports.AbstractSqlBuilder = AbstractSqlBuilder;
