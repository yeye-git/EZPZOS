import { SqlBuilder, SqlOperationStatic0, SqlOperationStatic1, SqlOperation1, SqlOperation2, ToSql, HasOperation, SqlSequenceOperation, SqlFragmentOperation, AggregateFunctions0, AggregateFunctions1, AggregateFunctions1or2, SqlFunction0, SqlComparator0, SelectData } from "../sqlBuilders/SqlBuilder";
import { BooleanValueSource, IntValueSource, DoubleValueSource, NumberValueSource, StringValueSource, TypeSafeStringValueSource, IValueSource, NullableValueSource, LocalDateValueSource, LocalTimeValueSource, LocalDateTimeValueSource, DateValueSource, TimeValueSource, DateTimeValueSource, StringIntValueSource, StringDoubleValueSource, StringNumberValueSource, __ValueSourcePrivate, IfValueSource, BigintValueSource, TypeSafeBigintValueSource, AlwaysIfValueSource, IAnyBooleanValueSource, AnyValueSource, ValueSource, OptionalType, IAggregatedArrayValueSource, AggregatedArrayValueSource, __AggregatedArrayColumns, __AggregatedArrayMode, UuidValueSource, TypeSafeUuidValueSource, AggregatedArrayValueSourceProjectableAsNullable, ValueType, CustomIntValueSource, CustomDoubleValueSource, CustomUuidValueSource, CustomLocalDateValueSource, CustomLocalTimeValueSource, CustomLocalDateTimeValueSource } from "../expressions/values";
import { TypeAdapter } from "../TypeAdapter";
import { HasAddWiths, HasIsValue, ITableOrView, IWithView } from "../utils/ITableOrView";
import { database, tableOrView, valueSourceType, valueType as valueType_, optionalType as optionalType_, booleanValueSourceType, comparableValueSourceType, dateTimeValueSourceType, dateValueSourceType, doubleValueSourceType, equalableValueSourceType, intValueSourceType, localDateTimeValueSourceType, localDateValueSourceType, localTimeValueSourceType, nullableValueSourceType, numberValueSourceType, stringDoubleValueSourceType, stringIntValueSourceType, stringNumberValueSourceType, stringValueSourceType, timeValueSourceType, typeSafeStringValueSourceType, ifValueSourceType, bigintValueSourceType, typeSafeBigintValueSourceType, valueSourceTypeName, anyBooleanValueSourceType, isValueSourceObject, aggregatedArrayValueSourceType, uuidValueSourceType, typeSafeUuidValueSourceType, customIntValueSourceType, customDoubleValueSourceType, customUuidValueSourceType, customLocalDateValueSourceType, customLocalTimeValueSourceType, customLocalDateTimeValueSourceType } from "../utils/symbols";
import { Column } from "../utils/Column";
import type { FragmentQueryBuilder } from "../queryBuilders/FragmentQueryBuilder";
export declare abstract class ValueSourceImpl implements IValueSource<any, any, any, any>, NullableValueSource<any, any, any, any>, BooleanValueSource<any, any>, IntValueSource<any, any>, StringIntValueSource<any, any>, DoubleValueSource<any, any>, StringDoubleValueSource<any, any>, NumberValueSource<any, any>, StringNumberValueSource<any, any>, BigintValueSource<any, any>, CustomIntValueSource<any, any, any, any>, CustomDoubleValueSource<any, any, any, any>, TypeSafeBigintValueSource<any, any>, StringValueSource<any, any>, TypeSafeStringValueSource<any, any>, LocalDateValueSource<any, any>, LocalTimeValueSource<any, any>, LocalDateTimeValueSource<any, any>, DateValueSource<any, any>, TimeValueSource<any, any>, DateTimeValueSource<any, any>, CustomLocalDateValueSource<any, any, any, any>, CustomLocalTimeValueSource<any, any, any, any>, CustomLocalDateTimeValueSource<any, any, any, any>, IfValueSource<any, any>, AlwaysIfValueSource<any, any>, IAnyBooleanValueSource<any, any>, IAggregatedArrayValueSource<any, any, any>, AggregatedArrayValueSource<any, any, any>, AggregatedArrayValueSourceProjectableAsNullable<any, any, any, any>, UuidValueSource<any, any>, TypeSafeUuidValueSource<any, any>, CustomUuidValueSource<any, any, any, any>, ToSql, __ValueSourcePrivate {
    [valueSourceType]: 'ValueSource';
    [nullableValueSourceType]: 'NullableValueSource';
    [equalableValueSourceType]: 'EqualableValueSource';
    [comparableValueSourceType]: 'ComparableValueSource';
    [booleanValueSourceType]: 'BooleanValueSource';
    [ifValueSourceType]: 'IfValueSource';
    [numberValueSourceType]: 'NumberValueSource';
    [stringNumberValueSourceType]: 'StringNumberValueSource';
    [intValueSourceType]: 'IntValueSource';
    [doubleValueSourceType]: 'DoubleValueSource';
    [bigintValueSourceType]: 'BigintValueSource';
    [customIntValueSourceType]: 'CustomIntValueSource';
    [customDoubleValueSourceType]: 'CustomDoubleValueSource';
    [typeSafeBigintValueSourceType]: 'TypeSafeBigintValueSource';
    [stringIntValueSourceType]: 'StringIntValueSource';
    [stringDoubleValueSourceType]: 'StringDoubleValueSource';
    [stringValueSourceType]: 'StringValueSource';
    [typeSafeStringValueSourceType]: 'TypeSafeStringValueSource';
    [dateValueSourceType]: 'DateValueSource';
    [timeValueSourceType]: 'TimeValueSource';
    [dateTimeValueSourceType]: 'DateTimeValueSource';
    [localDateValueSourceType]: 'LocalDateValueSource';
    [localTimeValueSourceType]: 'LocalTimeValueSource';
    [localDateTimeValueSourceType]: 'LocalDateTimeValueSource';
    [customLocalDateValueSourceType]: 'CustomLocalDateValueSource';
    [customLocalTimeValueSourceType]: 'CustomLocalTimeValueSource';
    [customLocalDateTimeValueSourceType]: 'CustomLocalDateTimeValueSource';
    [anyBooleanValueSourceType]: 'AnyBooleanValueSource';
    [aggregatedArrayValueSourceType]: 'AggregatedArrayValueSource';
    [uuidValueSourceType]: 'UuidValueSource';
    [customUuidValueSourceType]: 'CustomUuidValueSource';
    [typeSafeUuidValueSourceType]: 'TypeSafeUuidValueSource';
    [valueSourceTypeName]: any;
    [database]: any;
    [tableOrView]: any;
    [valueType_]: any;
    [optionalType_]: any;
    [isValueSourceObject]: true;
    __valueType: ValueType;
    __valueTypeName: string;
    __optionalType: OptionalType;
    __typeAdapter?: TypeAdapter;
    __isBooleanForCondition?: boolean;
    __aggregatedArrayColumns?: __AggregatedArrayColumns | AnyValueSource;
    __aggregatedArrayMode?: __AggregatedArrayMode;
    __uuidString?: boolean;
    constructor(valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined, aggregatedArrayColumns?: __AggregatedArrayColumns | AnyValueSource, aggregatedArrayMode?: __AggregatedArrayMode, uuidString?: boolean);
    abstract __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(_sqlBuilder: HasIsValue, _withs: Array<IWithView<any>>): void;
    __registerTableOrView(_sqlBuilder: HasIsValue, _requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(_sqlBuilder: HasIsValue, _requiredColumns: Set<Column>, _onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(_sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(_sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(_sqlBuilder: HasIsValue): boolean;
    isConstValue(): boolean;
    getConstValue(): any;
    allowWhen(when: boolean, error: string | Error): any;
    disallowWhen(when: boolean, error: string | Error): any;
    asOptional(): any;
    asRequiredInOptionalObject(): any;
    useEmptyArrayForNoValue(): any;
    asOptionalNonEmptyArray(): any;
    projectingOptionalValuesAsNullable(): any;
    isNull(): any;
    isNotNull(): any;
    equalsIfValue(value: any): any;
    equals(value: any): any;
    notEqualsIfValue(value: any): any;
    notEquals(value: any): any;
    isIfValue(value: any): any;
    is(value: any): any;
    isNotIfValue(value: any): any;
    isNot(value: any): any;
    asString(): any;
    onlyWhenOrNull(when: boolean): any;
    ignoreWhenAsNull(when: boolean): any;
    equalsInsensitiveIfValue(value: any): any;
    equalsInsensitive(value: any): any;
    notEqualsInsensitiveIfValue(value: any): any;
    notEqualsInsensitive(value: any): any;
    /** @deprecated use lessThanIfValue method instead */
    smallerIfValue(value: any): any;
    /** @deprecated use lessThan method instead */
    smaller(value: any): any;
    /** @deprecated use greaterThanIfValue method instead */
    largerIfValue(value: any): any;
    /** @deprecated use greaterThan method instead */
    larger(value: any): any;
    /** @deprecated use lessOrEqualsIfValue method instead */
    smallAsIfValue(value: any): any;
    /** @deprecated use lessOrEquals method instead */
    smallAs(value: any): any;
    /** @deprecated use greaterOrEqualsIfValue method instead */
    largeAsIfValue(value: any): any;
    /** @deprecated use greaterOrEquals method instead */
    largeAs(value: any): any;
    lessThanIfValue(value: any): any;
    lessThan(value: any): any;
    greaterThanIfValue(value: any): any;
    greaterThan(value: any): any;
    lessOrEqualsIfValue(value: any): any;
    lessOrEquals(value: any): any;
    greaterOrEqualsIfValue(value: any): any;
    greaterOrEquals(value: any): any;
    inIfValue(value: any): any;
    in(value: any): any;
    notInIfValue(value: any): any;
    notIn(value: any): any;
    inN(...value: any[]): any;
    notInN(...value: any[]): any;
    likeIfValue(value: any): any;
    like(value: any): any;
    notLikeIfValue(value: any): any;
    notLike(value: any): any;
    likeInsensitiveIfValue(value: any): any;
    likeInsensitive(value: any): any;
    notLikeInsensitiveIfValue(value: any): any;
    notLikeInsensitive(value: any): any;
    startsWithIfValue(value: any): any;
    startsWith(value: any): any;
    notStartsWithIfValue(value: any): any;
    notStartsWith(value: any): any;
    endsWithIfValue(value: any): any;
    endsWith(value: any): any;
    notEndsWithIfValue(value: any): any;
    notEndsWith(value: any): any;
    startsWithInsensitiveIfValue(value: any): any;
    startsWithInsensitive(value: any): any;
    notStartsWithInsensitiveIfValue(value: any): any;
    notStartsWithInsensitive(value: any): any;
    endsWithInsensitiveIfValue(value: any): any;
    endsWithInsensitive(value: any): any;
    notEndsWithInsensitiveIfValue(value: any): any;
    notEndsWithInsensitive(value: any): any;
    containsIfValue(value: any): any;
    contains(value: any): any;
    notContainsIfValue(value: any): any;
    notContains(value: any): any;
    containsInsensitiveIfValue(value: any): any;
    containsInsensitive(value: any): any;
    notContainsInsensitiveIfValue(value: any): any;
    notContainsInsensitive(value: any): any;
    between(value: any, value2: any): any;
    notBetween(value: any, value2: any): any;
    negate(): any;
    onlyWhen(condition: boolean): any;
    ignoreWhen(condition: boolean): any;
    trueWhenNoValue(): any;
    falseWhenNoValue(): any;
    valueWhenNoValue(value: any): any;
    toLowerCase(): any;
    /** @deprecated use toLowerCase method instead */
    lower(): any;
    toUpperCase(): any;
    /** @deprecated use toUpperCase method instead */
    upper(): any;
    length(): any;
    trim(): any;
    trimLeft(): any;
    /** @deprecated use trimLeft method instead */
    ltrim(): any;
    trimRight(): any;
    /** @deprecated use trimRight method instead */
    rtrim(): any;
    reverse(): any;
    asDouble(): any;
    /** @deprecated 'stringDouble' type is deprecated, define your customInt instead */
    asStringDouble(): any;
    asInt(): any;
    /** @deprecated 'stringInt' type is deprecated, define your customInt instead */
    asStringInt(): any;
    asBigint(): any;
    abs(): any;
    ceil(): any;
    floor(): any;
    round(): any;
    exp(): any;
    ln(): any;
    log10(): any;
    sqrt(): any;
    cbrt(): any;
    sign(): any;
    acos(): any;
    asin(): any;
    atan(): any;
    cos(): any;
    cot(): any;
    sin(): any;
    tan(): any;
    getDate(): any;
    getTime(): any;
    getFullYear(): any;
    getMonth(): any;
    getDay(): any;
    getHours(): any;
    getMinutes(): any;
    getSeconds(): any;
    getMilliseconds(): any;
    valueWhenNull(value: any): any;
    nullIfValue(value: any): any;
    and(value: any): any;
    or(value: any): any;
    atan2(value: any): any;
    concat(value: any): any;
    concatIfValue(value: any): any;
    substrToEnd(start: any): any;
    substringToEnd(start: any): any;
    power(value: any): any;
    logn(value: any): any;
    roundn(value: any): any;
    /**
     * This function establish a minimum value for the current value, that means the biggest value must be returned
     */
    minValue(value: any): any;
    /**
     * This function establish a maximun value for the current value, that means the smallest value must be returned
     */
    maxValue(value: any): any;
    add(value: any): any;
    substract(value: any): any;
    multiply(value: any): any;
    divide(value: any): any;
    modulo(value: any): any;
    /** @deprecated use modulo method instead */
    mod(value: any): any;
    substr(start: any, count: any): any;
    substring(start: any, end: any): any;
    /** @deprecated use replaceAllIfValue method instead */
    replaceIfValue(findString: any, replaceWith: any): any;
    /** @deprecated use replaceAll method instead */
    replace(findString: any, replaceWith: any): any;
    replaceAllIfValue(findString: any, replaceWith: any): any;
    replaceAll(findString: any, replaceWith: any): any;
    __prior(): any;
}
export declare class SqlOperationStatic0ValueSource extends ValueSourceImpl implements HasOperation {
    __operation: keyof SqlOperationStatic0;
    constructor(operation: keyof SqlOperationStatic0, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
}
export declare class SqlOperationStaticBooleanValueSource extends ValueSourceImpl implements HasOperation {
    __operation: keyof SqlOperationStatic0;
    constructor(operation: '_true' | '_false');
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string;
}
export declare class BooleanValueWhenNoValueValueSource extends ValueSourceImpl implements HasOperation {
    __valueSource: ValueSourceImpl;
    __operation: '_true' | '_false';
    constructor(operation: '_true' | '_false', valueSource: ValueSourceImpl, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class ValueWhenNoValueValueSource extends ValueSourceImpl {
    __valueSource: ValueSourceImpl;
    __valueWhenNoValue: __ValueSourcePrivate & ToSql;
    constructor(valueWhenNoValue: __ValueSourcePrivate & ToSql, valueSource: ValueSourceImpl, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class SqlOperationStatic1ValueSource extends ValueSourceImpl implements HasOperation {
    __operation: keyof SqlOperationStatic1;
    __value: any;
    constructor(operation: keyof SqlOperationStatic1, value: any, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class SqlOperationConstValueSource extends ValueSourceImpl implements HasOperation {
    __operation: keyof SqlOperationStatic1;
    __value: any;
    constructor(value: any, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string;
    isConstValue(): boolean;
    getConstValue(): any;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class SqlOperation0ValueSource extends ValueSourceImpl implements HasOperation {
    __valueSource: ValueSourceImpl;
    __operation: keyof SqlFunction0;
    constructor(operation: keyof SqlFunction0, valueSource: ValueSourceImpl, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class SqlOperationIsNullValueSource extends ValueSourceImpl implements HasOperation {
    __valueSource: ValueSourceImpl;
    __operation: keyof SqlComparator0;
    constructor(operation: keyof SqlComparator0, valueSource: ValueSourceImpl, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class SqlOperation1ValueSource extends ValueSourceImpl implements HasOperation {
    __valueSource: ValueSourceImpl;
    __operation: keyof SqlOperation1;
    __value: any;
    constructor(operation: keyof SqlOperation1, valueSource: ValueSourceImpl, value: any, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class SqlOperationInValueSource extends ValueSourceImpl implements HasOperation {
    __valueSource: ValueSourceImpl;
    __operation: '_in' | '_notIn';
    __value: any;
    constructor(operation: '_in' | '_notIn', valueSource: ValueSourceImpl, value: any, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class SqlOperationValueWhenNullValueSource extends ValueSourceImpl implements HasOperation {
    __valueSource: ValueSourceImpl;
    __operation: keyof SqlOperation1;
    __value: any;
    constructor(valueSource: ValueSourceImpl, value: any, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class SqlOperation1NotOptionalValueSource extends ValueSourceImpl implements HasOperation {
    __valueSource: ValueSourceImpl;
    __operation: keyof SqlOperation1;
    __value: any;
    constructor(operation: keyof SqlOperation1, valueSource: ValueSourceImpl, value: any, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class SqlOperation1ValueSourceIfValueOrNoop extends ValueSourceImpl implements HasOperation {
    __valueSource: ValueSourceImpl;
    __operation: keyof SqlOperation1;
    __value: any;
    constructor(operation: keyof SqlOperation1, valueSource: ValueSourceImpl, value: any, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class SqlOperationInValueSourceIfValueOrNoop extends ValueSourceImpl implements HasOperation {
    __valueSource: ValueSourceImpl;
    __operation: '_in' | '_notIn';
    __value: any;
    constructor(operation: '_in' | '_notIn', valueSource: ValueSourceImpl, value: any, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class SqlOperationValueSourceIfValueAlwaysNoop extends ValueSourceImpl {
    constructor();
    __toSql(_sqlBuilder: SqlBuilder, _params: any[]): string;
}
export declare class SqlOperation1ValueSourceIfValueOrIgnore extends ValueSourceImpl implements HasOperation {
    __valueSource: ValueSourceImpl;
    __operation: keyof SqlOperation1;
    __value: any;
    constructor(operation: keyof SqlOperation1, valueSource: ValueSourceImpl, value: any, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class SqlOperation2ValueSource extends ValueSourceImpl implements HasOperation {
    __valueSource: ValueSourceImpl;
    __operation: keyof SqlOperation2;
    __value: any;
    __value2: any;
    constructor(operation: keyof SqlOperation2, valueSource: ValueSourceImpl, value: any, value2: any, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter?: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class SqlOperation2ValueSourceIfValueOrIgnore extends ValueSourceImpl implements HasOperation {
    __valueSource: ValueSourceImpl;
    __operation: keyof SqlOperation2;
    __value: any;
    __value2: any;
    constructor(operation: keyof SqlOperation2, valueSource: ValueSourceImpl, value: any, value2: any, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter?: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class NoopValueSource extends ValueSourceImpl {
    __valueSource: ValueSourceImpl;
    constructor(valueSource: ValueSourceImpl, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class SequenceValueSource extends ValueSourceImpl {
    __operation: keyof SqlSequenceOperation;
    __sequenceName: string;
    constructor(operation: keyof SqlSequenceOperation, sequenceName: string, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
}
export declare class FragmentValueSource extends ValueSourceImpl {
    __operation: keyof SqlFragmentOperation;
    __sql: TemplateStringsArray;
    __sqlParams: AnyValueSource[];
    constructor(sql: TemplateStringsArray, sqlParams: AnyValueSource[], valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class ValueSourceFromBuilder extends ValueSourceImpl {
    __builder: (fragmentBuilder: FragmentQueryBuilder) => AnyValueSource;
    __fragmentBuilder: FragmentQueryBuilder;
    __builderOutput?: AnyValueSource;
    constructor(builder: (fragmentBuilder: FragmentQueryBuilder) => AnyValueSource, fragmentBuilder: FragmentQueryBuilder, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __getBuilderOutput(): AnyValueSource;
    __getBuilderOutputPrivate(): __ValueSourcePrivate;
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class AllowWhenValueSource extends ValueSourceImpl {
    __valueSource: ValueSourceImpl;
    __allowed: boolean;
    __error: Error;
    constructor(allowed: boolean, error: Error, valueSource: ValueSourceImpl);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class AggregateFunctions0ValueSource extends ValueSourceImpl implements HasOperation {
    __operation: keyof AggregateFunctions0;
    constructor(operation: keyof AggregateFunctions0, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
}
export declare class NullValueSource extends ValueSourceImpl implements HasOperation {
    __operation: "_asNullValue";
    constructor(valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __isAllowed(_sqlBuilder: HasIsValue): boolean;
}
export declare class AggregateFunctions1ValueSource extends ValueSourceImpl implements HasOperation {
    __operation: keyof AggregateFunctions1;
    __value: any;
    constructor(operation: keyof AggregateFunctions1, value: any, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class AggregateFunctions1or2ValueSource extends ValueSourceImpl implements HasOperation {
    __operation: keyof AggregateFunctions1or2;
    __value: any;
    __separator: string | undefined;
    constructor(operation: keyof AggregateFunctions1or2, separator: string | undefined, value: any, valueType: ValueType, valueTypeName: string, optionalType: OptionalType, typeAdapter: TypeAdapter | undefined);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class TableOrViewRawFragmentValueSource implements ValueSource<any, any, any, any>, __ValueSourcePrivate, ToSql {
    [tableOrView]: any;
    [valueType_]: any;
    [optionalType_]: any;
    [valueSourceType]: "ValueSource";
    [database]: any;
    [valueSourceTypeName]: any;
    [isValueSourceObject]: true;
    __valueType: ValueType;
    __valueTypeName: string;
    __optionalType: OptionalType;
    __typeAdapter?: TypeAdapter | undefined;
    __tableOrView: ITableOrView<any>;
    __operation: '_rawFragmentTableName' | '_rawFragmentTableAlias';
    constructor(_tableOrView: ITableOrView<any>, operation: '_rawFragmentTableName' | '_rawFragmentTableAlias');
    isConstValue(): boolean;
    getConstValue(): any;
    allowWhen(when: boolean, error: string | Error): any;
    disallowWhen(when: boolean, error: string | Error): any;
    __addWiths(_sqlBuilder: HasIsValue, _withs: IWithView<any>[]): void;
    __registerTableOrView(_sqlBuilder: HasIsValue, _requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(_sqlBuilder: HasIsValue, _requiredColumns: Set<Column>, _onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(_sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(_sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(_sqlBuilder: HasIsValue): boolean;
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string;
}
export declare class AllowWhenTableOrViewRawFragmentValueSource extends TableOrViewRawFragmentValueSource {
    __allowed: boolean;
    __error: Error;
    constructor(allowed: boolean, error: Error, _tableOrView: ITableOrView<any>, operation: '_rawFragmentTableName' | '_rawFragmentTableAlias');
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export type InlineSelectData = SelectData & HasAddWiths;
export declare class InlineSelectValueSource extends ValueSourceImpl implements HasOperation {
    __operation: "_inlineSelectAsValue";
    __selectData: InlineSelectData;
    constructor(selectData: InlineSelectData, required: boolean);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: IWithView<any>[]): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class AggregateSelectValueSource implements ValueSource<any, any, any, any>, IAggregatedArrayValueSource<any, any, any>, AggregatedArrayValueSource<any, any, any>, AggregatedArrayValueSourceProjectableAsNullable<any, any, any, any>, __ValueSourcePrivate, ToSql {
    [tableOrView]: any;
    [valueType_]: any;
    [optionalType_]: any;
    [valueSourceType]: "ValueSource";
    [database]: any;
    [valueSourceTypeName]: any;
    [aggregatedArrayValueSourceType]: 'AggregatedArrayValueSource';
    [isValueSourceObject]: true;
    __valueType: ValueType;
    __valueTypeName: string;
    __optionalType: OptionalType;
    __operation: "_inlineSelectAsValue";
    __selectData: InlineSelectData;
    __aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource;
    __aggregatedArrayMode: __AggregatedArrayMode;
    __aggreagtedProjectingOptionalValuesAsNullable?: boolean;
    constructor(selectData: InlineSelectData, aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource, aggregatedArrayMode: __AggregatedArrayMode, _optionalType: OptionalType);
    isConstValue(): boolean;
    getConstValue(): any;
    allowWhen(when: boolean, error: string | Error): any;
    disallowWhen(when: boolean, error: string | Error): any;
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(sqlBuilder: HasIsValue, withs: IWithView<any>[]): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
    useEmptyArrayForNoValue(): any;
    asOptionalNonEmptyArray(): any;
    asRequiredInOptionalObject(): any;
    onlyWhenOrNull(when: boolean): any;
    ignoreWhenAsNull(when: boolean): any;
    projectingOptionalValuesAsNullable(): any;
}
export declare class AllowWhenAggregateSelectValueSource extends AggregateSelectValueSource {
    __allowed: boolean;
    __error: Error;
    constructor(allowed: boolean, error: Error, selectData: InlineSelectData, aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource, aggregatedArrayMode: __AggregatedArrayMode, _optionalType: OptionalType);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class NullAggregateSelectValueSource implements ValueSource<any, any, any, any>, IAggregatedArrayValueSource<any, any, any>, AggregatedArrayValueSource<any, any, any>, AggregatedArrayValueSourceProjectableAsNullable<any, any, any, any>, __ValueSourcePrivate, ToSql {
    [tableOrView]: any;
    [valueType_]: any;
    [optionalType_]: any;
    [valueSourceType]: "ValueSource";
    [database]: any;
    [valueSourceTypeName]: any;
    [aggregatedArrayValueSourceType]: 'AggregatedArrayValueSource';
    [isValueSourceObject]: true;
    __valueType: ValueType;
    __valueTypeName: string;
    __optionalType: OptionalType;
    __operation: "_inlineSelectAsValue";
    __selectData: InlineSelectData;
    __aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource;
    __aggregatedArrayMode: __AggregatedArrayMode;
    constructor(selectData: InlineSelectData, aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource, aggregatedArrayMode: __AggregatedArrayMode, _optionalType: OptionalType);
    isConstValue(): boolean;
    getConstValue(): any;
    allowWhen(when: boolean, error: string | Error): any;
    disallowWhen(when: boolean, error: string | Error): any;
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(_sqlBuilder: HasIsValue, _withs: IWithView<any>[]): void;
    __registerTableOrView(_sqlBuilder: HasIsValue, _requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(_sqlBuilder: HasIsValue, _requiredColumns: Set<Column>, _onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(_sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(_sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(_sqlBuilder: HasIsValue): boolean;
    useEmptyArrayForNoValue(): any;
    asOptionalNonEmptyArray(): any;
    asRequiredInOptionalObject(): any;
    onlyWhenOrNull(when: boolean): any;
    ignoreWhenAsNull(when: boolean): any;
    projectingOptionalValuesAsNullable(): any;
}
export declare class NullAllowWhenAggregateSelectValueSource extends NullAggregateSelectValueSource {
    __allowed: boolean;
    __error: Error;
    constructor(selectData: InlineSelectData, allowed: boolean, error: Error, aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource, aggregatedArrayMode: __AggregatedArrayMode, _optionalType: OptionalType);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class AggregateValueAsArrayValueSource implements ValueSource<any, any, any, any>, IAggregatedArrayValueSource<any, any, any>, AggregatedArrayValueSource<any, any, any>, AggregatedArrayValueSourceProjectableAsNullable<any, any, any, any>, __ValueSourcePrivate, ToSql {
    [tableOrView]: any;
    [valueType_]: any;
    [optionalType_]: any;
    [valueSourceType]: "ValueSource";
    [database]: any;
    [valueSourceTypeName]: any;
    [aggregatedArrayValueSourceType]: 'AggregatedArrayValueSource';
    [isValueSourceObject]: true;
    __valueType: ValueType;
    __valueTypeName: string;
    __optionalType: OptionalType;
    __operation: '_aggregateValueAsArray';
    __aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource;
    __aggregatedArrayMode: __AggregatedArrayMode;
    __aggreagtedProjectingOptionalValuesAsNullable?: boolean;
    __aggregatedArrayDistinct: boolean;
    constructor(aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource, aggregatedArrayMode: __AggregatedArrayMode, _optionalType: OptionalType, distict: boolean);
    isConstValue(): boolean;
    getConstValue(): any;
    allowWhen(when: boolean, error: string | Error): any;
    disallowWhen(when: boolean, error: string | Error): any;
    __addWiths(sqlBuilder: HasIsValue, withs: IWithView<any>[]): void;
    __addWithsOf(sqlBuilder: HasIsValue, withs: IWithView<any>[], aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource | null | undefined): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerTableOrViewOf(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>, aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource | null | undefined): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumnOf(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>, aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource | null | undefined): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getOldValuesOf(sqlBuilder: HasIsValue, aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource | null | undefined): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsertOf(sqlBuilder: HasIsValue, aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource | null | undefined): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
    __isAllowedOf(sqlBuilder: HasIsValue, aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource | null | undefined): boolean;
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string;
    useEmptyArrayForNoValue(): any;
    asOptionalNonEmptyArray(): any;
    asRequiredInOptionalObject(): any;
    onlyWhenOrNull(when: boolean): any;
    ignoreWhenAsNull(when: boolean): any;
    projectingOptionalValuesAsNullable(): any;
}
export declare class AllowWhenAggregateValueAsArrayValueSource extends AggregateValueAsArrayValueSource {
    __allowed: boolean;
    __error: Error;
    constructor(allowed: boolean, error: Error, aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource, aggregatedArrayMode: __AggregatedArrayMode, _optionalType: OptionalType, distinct: boolean);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class NullAggregateValueAsArrayValueSource implements ValueSource<any, any, any, any>, IAggregatedArrayValueSource<any, any, any>, AggregatedArrayValueSource<any, any, any>, AggregatedArrayValueSourceProjectableAsNullable<any, any, any, any>, __ValueSourcePrivate, ToSql {
    [tableOrView]: any;
    [valueType_]: any;
    [optionalType_]: any;
    [valueSourceType]: "ValueSource";
    [database]: any;
    [valueSourceTypeName]: any;
    [aggregatedArrayValueSourceType]: 'AggregatedArrayValueSource';
    [isValueSourceObject]: true;
    __valueType: ValueType;
    __valueTypeName: string;
    __optionalType: OptionalType;
    __operation: '_aggregateValueAsArray';
    __aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource;
    __aggregatedArrayMode: __AggregatedArrayMode;
    __aggregatedArrayDistinct: boolean;
    constructor(aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource, aggregatedArrayMode: __AggregatedArrayMode, _optionalType: OptionalType, distinct: boolean);
    isConstValue(): boolean;
    getConstValue(): any;
    allowWhen(when: boolean, error: string | Error): any;
    disallowWhen(when: boolean, error: string | Error): any;
    __addWiths(_sqlBuilder: HasIsValue, _withs: IWithView<any>[]): void;
    __registerTableOrView(_sqlBuilder: HasIsValue, _requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(_sqlBuilder: HasIsValue, _requiredColumns: Set<Column>, _onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(_sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(_sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(_sqlBuilder: HasIsValue): boolean;
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string;
    useEmptyArrayForNoValue(): any;
    asOptionalNonEmptyArray(): any;
    asRequiredInOptionalObject(): any;
    onlyWhenOrNull(when: boolean): any;
    ignoreWhenAsNull(when: boolean): any;
    projectingOptionalValuesAsNullable(): any;
}
export declare class NullAllowWhenAggregateValueAsArrayValueSource extends NullAggregateValueAsArrayValueSource {
    __allowed: boolean;
    __error: Error;
    constructor(allowed: boolean, error: Error, aggregatedArrayColumns: __AggregatedArrayColumns | AnyValueSource, aggregatedArrayMode: __AggregatedArrayMode, _optionalType: OptionalType, distinct: boolean);
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
