"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeType = exports.extractWritableShapeFrom = exports.extractProvidedIdColumnNamesFrom = exports.extractAutogeneratedIdColumnNamesFrom = exports.extractIdColumnNamesFrom = exports.extractWritableColumnNamesFrom = exports.extractColumnNamesFrom = exports.extractProvidedIdColumnsFrom = exports.extractAutogeneratedIdColumnsFrom = exports.extractIdColumnsFrom = exports.extractWritableColumnsFrom = exports.extractColumnsFrom = exports.prefixMapForGuidedSplitDotted = exports.prefixMapForSplitDotted = exports.prefixDotted = exports.mapForGuidedSplit = exports.prefixMapForGuidedSplitCapitalized = exports.prefixMapForSplitCapitalized = exports.prefixCapitalized = void 0;
const values_1 = require("../expressions/values");
const Column_1 = require("../utils/Column");
/** @deprecated Use complex projections or aggregate as an object array instead */
function prefixCapitalized(obj, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        result[prefix + key.substr(0, 1).toUpperCase() + key.substr(1)] = obj[key];
    }
    return result;
}
exports.prefixCapitalized = prefixCapitalized;
/** @deprecated Use complex projections or aggregate as an object array instead */
function prefixMapForSplitCapitalized(obj, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        result[key] = prefix + key.substr(0, 1).toUpperCase() + key.substr(1);
    }
    return result;
}
exports.prefixMapForSplitCapitalized = prefixMapForSplitCapitalized;
/** @deprecated Use complex projections or aggregate as an object array instead */
function prefixMapForGuidedSplitCapitalized(obj, reference, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        const r = reference[key];
        if ((0, values_1.isValueSource)(r) && (0, values_1.__getValueSourcePrivate)(r).__optionalType === 'required') {
            result[key] = prefix + key.substr(0, 1).toUpperCase() + key.substr(1) + '!';
        }
        else {
            result[key] = prefix + key.substr(0, 1).toUpperCase() + key.substr(1);
        }
    }
    return result;
}
exports.prefixMapForGuidedSplitCapitalized = prefixMapForGuidedSplitCapitalized;
/** @deprecated Use complex projections or aggregate as an object array instead */
function mapForGuidedSplit(obj, reference) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        const r = reference[key];
        if ((0, values_1.isValueSource)(r) && (0, values_1.__getValueSourcePrivate)(r).__optionalType === 'required') {
            result[key] = key + '!';
        }
        else {
            result[key] = key;
        }
    }
    return result;
}
exports.mapForGuidedSplit = mapForGuidedSplit;
/** @deprecated Use complex projections or aggregate as an object array instead */
function prefixDotted(obj, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        result[prefix + '.' + key] = obj[key];
    }
    return result;
}
exports.prefixDotted = prefixDotted;
/** @deprecated Use complex projections or aggregate as an object array instead */
function prefixMapForSplitDotted(obj, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        result[key] = prefix + '.' + key;
    }
    return result;
}
exports.prefixMapForSplitDotted = prefixMapForSplitDotted;
/** @deprecated Use complex projections or aggregate as an object array instead */
function prefixMapForGuidedSplitDotted(obj, reference, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        const r = reference[key];
        if ((0, values_1.isValueSource)(r) && (0, values_1.__getValueSourcePrivate)(r).__optionalType === 'required') {
            result[key] = prefix + '.' + key + '!';
        }
        else {
            result[key] = prefix + '.' + key;
        }
    }
    return result;
}
exports.prefixMapForGuidedSplitDotted = prefixMapForGuidedSplitDotted;
function extractColumnsFrom(obj, exclude) {
    if (!obj) {
        return obj;
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = {};
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, values_1.isValueSource)(value)) {
            result[key] = value;
        }
    }
    return result;
}
exports.extractColumnsFrom = extractColumnsFrom;
function extractWritableColumnsFrom(obj, exclude) {
    if (!obj) {
        return obj;
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = {};
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, Column_1.isColumn)(value)) {
            if (!(0, Column_1.__getColumnPrivate)(value).__isComputed) {
                result[key] = value;
            }
        }
    }
    return result;
}
exports.extractWritableColumnsFrom = extractWritableColumnsFrom;
function extractIdColumnsFrom(obj, exclude) {
    if (!obj) {
        return obj;
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = {};
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, Column_1.isColumn)(value)) {
            const columnPrivate = (0, Column_1.__getColumnPrivate)(value);
            if (columnPrivate.__isPrimaryKey) {
                result[key] = value;
            }
        }
    }
    return result;
}
exports.extractIdColumnsFrom = extractIdColumnsFrom;
function extractAutogeneratedIdColumnsFrom(obj, exclude) {
    if (!obj) {
        return obj;
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = {};
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, Column_1.isColumn)(value)) {
            const columnPrivate = (0, Column_1.__getColumnPrivate)(value);
            if (columnPrivate.__isAutogeneratedPrimaryKey) {
                result[key] = value;
            }
        }
    }
    return result;
}
exports.extractAutogeneratedIdColumnsFrom = extractAutogeneratedIdColumnsFrom;
function extractProvidedIdColumnsFrom(obj, exclude) {
    if (!obj) {
        return obj;
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = {};
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, Column_1.isColumn)(value)) {
            const columnPrivate = (0, Column_1.__getColumnPrivate)(value);
            if (columnPrivate.__isPrimaryKey && !columnPrivate.__isAutogeneratedPrimaryKey) {
                result[key] = value;
            }
        }
    }
    return result;
}
exports.extractProvidedIdColumnsFrom = extractProvidedIdColumnsFrom;
function extractColumnNamesFrom(obj, exclude) {
    if (!obj) {
        return [];
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = [];
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, values_1.isValueSource)(value)) {
            result.push(key);
        }
    }
    return result;
}
exports.extractColumnNamesFrom = extractColumnNamesFrom;
function extractWritableColumnNamesFrom(obj, exclude) {
    if (!obj) {
        return [];
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = [];
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, Column_1.isColumn)(value)) {
            if (!(0, Column_1.__getColumnPrivate)(value).__isComputed) {
                result.push(key);
            }
        }
    }
    return result;
}
exports.extractWritableColumnNamesFrom = extractWritableColumnNamesFrom;
function extractIdColumnNamesFrom(obj, exclude) {
    if (!obj) {
        return [];
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = [];
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, Column_1.isColumn)(value)) {
            const columnPrivate = (0, Column_1.__getColumnPrivate)(value);
            if (columnPrivate.__isPrimaryKey) {
                result.push(key);
            }
        }
    }
    return result;
}
exports.extractIdColumnNamesFrom = extractIdColumnNamesFrom;
function extractAutogeneratedIdColumnNamesFrom(obj, exclude) {
    if (!obj) {
        return [];
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = [];
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, Column_1.isColumn)(value)) {
            const columnPrivate = (0, Column_1.__getColumnPrivate)(value);
            if (columnPrivate.__isAutogeneratedPrimaryKey) {
                result.push(key);
            }
        }
    }
    return result;
}
exports.extractAutogeneratedIdColumnNamesFrom = extractAutogeneratedIdColumnNamesFrom;
function extractProvidedIdColumnNamesFrom(obj, exclude) {
    if (!obj) {
        return [];
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = [];
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, Column_1.isColumn)(value)) {
            const columnPrivate = (0, Column_1.__getColumnPrivate)(value);
            if (columnPrivate.__isPrimaryKey && !columnPrivate.__isAutogeneratedPrimaryKey) {
                result.push(key);
            }
        }
    }
    return result;
}
exports.extractProvidedIdColumnNamesFrom = extractProvidedIdColumnNamesFrom;
function extractWritableShapeFrom(obj, exclude) {
    if (!obj) {
        return obj;
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = {};
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, Column_1.isColumn)(value)) {
            if (!(0, Column_1.__getColumnPrivate)(value).__isComputed) {
                result[key] = key;
            }
        }
    }
    return result;
}
exports.extractWritableShapeFrom = extractWritableShapeFrom;
/** @deprecated Use connection.dynamicBooleanExpressionUsing instead */
function mergeType(value) {
    return value;
}
exports.mergeType = mergeType;
