"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.callDeferredFunctionsStoppingOnError = exports.callDeferredFunctions = exports.isPromise = void 0;
const chained_error_1 = require("chained-error");
const attachSource_1 = require("./attachSource");
function isPromise(value) {
    return value && (typeof value === 'object') && (typeof value.then === 'function');
}
exports.isPromise = isPromise;
function callDeferredFunctions(name, fns, result, source, transactionError, throwError) {
    return internalCallDeferredFunctions(false, name, fns, result, source, transactionError, throwError);
}
exports.callDeferredFunctions = callDeferredFunctions;
function callDeferredFunctionsStoppingOnError(name, fns, result, source, transactionError, throwError) {
    return internalCallDeferredFunctions(true, name, fns, result, source, transactionError, throwError);
}
exports.callDeferredFunctionsStoppingOnError = callDeferredFunctionsStoppingOnError;
function internalCallDeferredFunctions(stopOnFistError, name, fns, result, source, transactionError, throwError) {
    if (!fns) {
        if (throwError) {
            throw throwError;
        }
        return result;
    }
    let promise;
    // A containner is required to allow other functions to modify the value
    const errorContainer = {
        error: throwError,
        name,
        source,
        transactionError
    };
    for (let i = 0, length = fns.length; i < length; i++) {
        if (!promise) {
            try {
                const fnResult = fns[i]();
                if (isPromise(fnResult)) {
                    promise = fnResult;
                }
            }
            catch (e) {
                if (errorContainer.error) {
                    (0, attachSource_1.attachAdditionalError)(errorContainer.error, e, name);
                }
                else {
                    errorContainer.error = (0, attachSource_1.attachTransactionSource)(new chained_error_1.default('Error executing ' + name + ' functions', e), source);
                    if (transactionError) {
                        (0, attachSource_1.attachTransactionError)(errorContainer.error, transactionError);
                    }
                }
            }
        }
        else {
            const fn = fns[i];
            promise = promise.then(callDeferredFunctionAsThen.bind(undefined, fn, errorContainer, true), stopOnFistError ? undefined : callDeferredFunctionAsThen.bind(undefined, fn, errorContainer, false));
        }
    }
    if (promise) {
        return promise.then(() => {
            if (errorContainer.error) {
                throw errorContainer.error;
            }
            return result;
        }, (e) => {
            if (errorContainer.error) {
                (0, attachSource_1.attachAdditionalError)(errorContainer.error, e, errorContainer.name);
            }
            else {
                errorContainer.error = (0, attachSource_1.attachTransactionSource)(new chained_error_1.default('Error executing ' + errorContainer.name + ' functions', e), errorContainer.source);
                if (errorContainer.transactionError) {
                    (0, attachSource_1.attachTransactionError)(errorContainer.error, errorContainer.transactionError);
                }
            }
            throw errorContainer.error;
        });
    }
    if (errorContainer.error) {
        throw errorContainer.error;
    }
    return result;
}
function callDeferredFunctionAsThen(fn, errorContainer, isThen, executionError) {
    if (!isThen && executionError) {
        if (errorContainer.error) {
            (0, attachSource_1.attachAdditionalError)(errorContainer.error, executionError, errorContainer.name);
        }
        else {
            errorContainer.error = (0, attachSource_1.attachTransactionSource)(new chained_error_1.default('Error executing ' + errorContainer.name + ' functions', executionError), errorContainer.source);
            if (errorContainer.transactionError) {
                (0, attachSource_1.attachTransactionError)(errorContainer.error, errorContainer.transactionError);
            }
        }
    }
    try {
        const fnResult = fn();
        if (isPromise(fnResult)) {
            return fnResult;
        }
    }
    catch (e) {
        if (errorContainer.error) {
            (0, attachSource_1.attachAdditionalError)(errorContainer.error, e, errorContainer.name);
        }
        else {
            errorContainer.error = (0, attachSource_1.attachTransactionSource)(new chained_error_1.default('Error executing ' + errorContainer.name + ' functions', e), errorContainer.source);
            if (errorContainer.transactionError) {
                (0, attachSource_1.attachTransactionError)(errorContainer.error, errorContainer.transactionError);
            }
        }
    }
}
