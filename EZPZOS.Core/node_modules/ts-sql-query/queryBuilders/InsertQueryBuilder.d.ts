import { SqlBuilder, InsertData, SelectData, ToSql } from "../sqlBuilders/SqlBuilder";
import { HasAddWiths, HasIsValue, ITable, ITableOrView, IWithView } from "../utils/ITableOrView";
import type { InsertExpression, ExecutableInsertExpression, ExecutableInsert, ExecutableInsertReturning, CustomizableExecutableMultipleInsert, CustomizableExecutableInsertFromSelect, /*MissingKeysInsertExpression, ShapedMissingKeysInsertExpression, MissingKeysMultipleInsertExpression, ShapedMissingKeysMultipleInsertExpression*/ InsertCustomization, CustomizableExecutableInsertReturningLastInsertedId, CustomizableExecutableSimpleInsert, ComposableExecutableInsert, ComposeExpression, ComposeExpressionDeletingInternalProperty, ComposeExpressionDeletingExternalProperty, ComposableCustomizableExecutableInsert, ExecutableInsertReturningLastInsertedId, InsertColumns, CustomizableExecutableInsert, OnConflictDoMultipleInsert, InsertOnConflictSetsExpression, DynamicOnConflictWhereExpression, OnConflictOnColumnWhere, CustomizableExecutableInsertFromSelectOnConflict, CustomizableExecutableSimpleInsertOnConflict, OnConflictDoSimpleInsert, CustomizableExecutableMultipleInsertOnConfict, CustomizableExecutableInsertFromSelectOnConflictOptional, CustomizableExecutableSimpleInsertOnConflictOptional, CustomizableExecutableMultipleInsertOnConfictOptional, ExecutableMultipleInsertExpression, ShapedExecutableInsertExpression, ShapedExecutableMultipleInsertExpression, ShapedInsertExpression, ShapedInsertOnConflictSetsExpression, ComposableCustomizableExecutableInsertProjectableAsNullable, ComposableCustomizableExecutableInsertOptionalProjectableAsNullable } from "../expressions/insert";
import { Column } from "../utils/Column";
import { database, resultType, tableOrView, type } from "../utils/symbols";
import { AlwaysIfValueSource, AnyValueSource, IBooleanValueSource, IExecutableSelectQuery, IIfValueSource, IStringValueSource, ITypeSafeStringValueSource } from "../expressions/values";
import { ComposeSplitQueryBuilder } from "./ComposeSliptQueryBuilder";
import { RawFragment } from "../utils/RawFragment";
export declare class InsertQueryBuilder extends ComposeSplitQueryBuilder implements HasAddWiths, ToSql, InsertExpression<any>, ShapedInsertExpression<any, any, any>, ExecutableInsertReturningLastInsertedId<any, any>, ExecutableInsert<any>, ExecutableInsertExpression<any>, ShapedExecutableInsertExpression<any, any>, ExecutableMultipleInsertExpression<any>, ShapedExecutableMultipleInsertExpression<any, any>, CustomizableExecutableMultipleInsert<any, any>, CustomizableExecutableInsertFromSelect<any, any>, CustomizableExecutableInsertReturningLastInsertedId<any, any>, CustomizableExecutableSimpleInsert<any, any>, /*MissingKeysInsertExpression<any, any>, ShapedMissingKeysInsertExpression<any, any, any>, MissingKeysMultipleInsertExpression<any, any>, ShapedMissingKeysMultipleInsertExpression<any, any, any>,*/ InsertData, ComposableExecutableInsert<any, any, any>, ComposeExpression<any, any, any, any, any, any>, ComposeExpressionDeletingInternalProperty<any, any, any, any, any, any>, ComposeExpressionDeletingExternalProperty<any, any, any, any, any, any>, ComposableCustomizableExecutableInsert<any, any, any>, ExecutableInsertReturning<any, any, any>, ExecutableInsert<any>, CustomizableExecutableInsert<any>, OnConflictDoMultipleInsert<any, any>, InsertOnConflictSetsExpression<any, any, any>, ShapedInsertOnConflictSetsExpression<any, any, any, any>, DynamicOnConflictWhereExpression<any, any>, OnConflictOnColumnWhere<any, any>, CustomizableExecutableInsertFromSelectOnConflict<any>, CustomizableExecutableSimpleInsertOnConflict<any>, OnConflictDoSimpleInsert<any, any>, CustomizableExecutableMultipleInsertOnConfict<any>, CustomizableExecutableInsertFromSelectOnConflictOptional<any>, CustomizableExecutableSimpleInsertOnConflictOptional<any>, CustomizableExecutableMultipleInsertOnConfictOptional<any>, ComposableCustomizableExecutableInsertProjectableAsNullable<any, any>, ComposableCustomizableExecutableInsertOptionalProjectableAsNullable<any, any> {
    [type]: any;
    [database]: any;
    [tableOrView]: any;
    [resultType]: any;
    __table: ITable<any>;
    __shape?: {
        [property: string]: string;
    };
    __sets: {
        [property: string]: any;
    };
    __multiple?: {
        [property: string]: any;
    }[];
    __multipleAlreadyCopied?: boolean;
    __isMultiple: boolean;
    __idColumn?: Column;
    __from?: SelectData;
    __withs: Array<IWithView<any>>;
    __customization?: InsertCustomization<any>;
    __onConflictOnConstraint?: string | IStringValueSource<any, any> | ITypeSafeStringValueSource<any, any> | RawFragment<any>;
    __onConflictOnColumns?: AnyValueSource[];
    __onConflictOnColumnsWhere?: AlwaysIfValueSource<any, any>;
    __onConflictDoNothing?: boolean;
    __onConflictUpdateShape?: {
        [property: string]: string;
    };
    __onConflictUpdateSets?: {
        [property: string]: any;
    };
    __onConflictUpdateWhere?: AlwaysIfValueSource<any, any>;
    __valuesForInsert?: ITableOrView<any>;
    __oneColumn?: boolean;
    __query: string;
    __params: any[];
    constructor(sqlBuilder: SqlBuilder, table: ITable<any>);
    executeInsert(min?: number, max?: number): Promise<any>;
    executeInsertNoneOrOne(): Promise<any>;
    executeInsertOne(): Promise<any>;
    executeInsertMany(min?: number, max?: number): Promise<any>;
    query(): string;
    params(): any[];
    __toSql(_sqlBuilder: SqlBuilder, params: any[]): string;
    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string;
    shapedAs(shape: any): any;
    extendShape(extendShape: any): this;
    dynamicSet(columns?: any): any;
    __getSetsForMultipleInsert(): {
        [property: string]: any;
    }[];
    set(columns: any): this;
    setIfValue(columns: any): this;
    setIfSet(columns: any): this;
    setIfSetIfValue(columns: any): this;
    setIfNotSet(columns: any): this;
    setIfNotSetIfValue(columns: any): this;
    ignoreIfSet(...columns: any[]): any;
    keepOnly(...columns: any[]): any;
    setIfHasValue(columns: any): this;
    setIfHasValueIfValue(columns: any): this;
    setIfHasNoValue(columns: any): this;
    setIfHasNoValueIfValue(columns: any): this;
    ignoreIfHasValue(...columns: any[]): this;
    ignoreIfHasNoValue(...columns: any[]): this;
    ignoreAnySetWithNoValue(): this;
    setForAll(columns: any): this;
    setForAllIfValue(columns: any): this;
    setForAllIfSet(columns: any): this;
    setForAllIfSetIfValue(columns: any): this;
    setForAllIfNotSet(columns: any): this;
    setForAllIfNotSetIfValue(columns: any): this;
    setForAllIfHasValue(columns: any): this;
    setForAllIfHasValueIfValue(columns: any): this;
    setForAllIfHasNoValue(columns: any): this;
    setForAllIfHasNoValueIfValue(columns: any): this;
    disallowIfSet(error: string | Error, ...columns: any[]): this;
    disallowIfNotSet(error: string | Error, ...columns: any[]): this;
    disallowIfValue(error: string | Error, ...columns: any[]): this;
    disallowIfNoValue(error: string | Error, ...columns: any[]): this;
    disallowAnyOtherSet(error: string | Error, ...columns: any[]): this;
    setWhen(when: boolean, columns: any): this;
    setIfValueWhen(when: boolean, columns: any): this;
    setIfSetWhen(when: boolean, columns: any): this;
    setIfSetIfValueWhen(when: boolean, columns: any): this;
    setIfNotSetWhen(when: boolean, columns: any): this;
    setIfNotSetIfValueWhen(when: boolean, columns: any): this;
    ignoreIfSetWhen(when: boolean, ...columns: any[]): this;
    keepOnlyWhen(when: boolean, ...columns: any[]): this;
    setIfHasValueWhen(when: boolean, columns: any): this;
    setIfHasValueIfValueWhen(when: boolean, columns: any): this;
    setIfHasNoValueWhen(when: boolean, columns: any): this;
    setIfHasNoValueIfValueWhen(when: boolean, columns: any): this;
    ignoreIfHasValueWhen(when: boolean, ...columns: any[]): this;
    ignoreIfHasNoValueWhen(when: boolean, ...columns: any[]): this;
    ignoreAnySetWithNoValueWhen(when: boolean): this;
    setForAllWhen(when: boolean, columns: any): this;
    setForAllIfValueWhen(when: boolean, columns: any): this;
    setForAllIfSetWhen(when: boolean, columns: any): this;
    setForAllIfSetIfValueWhen(when: boolean, columns: any): this;
    setForAllIfNotSetWhen(when: boolean, columns: any): this;
    setForAllIfNotSetIfValueWhen(when: boolean, columns: any): this;
    setForAllIfHasValueWhen(when: boolean, columns: any): this;
    setForAllIfHasValueIfValueWhen(when: boolean, columns: any): this;
    setForAllIfHasNoValueWhen(when: boolean, columns: any): this;
    setForAllIfHasNoValueIfValueWhen(when: boolean, columns: any): this;
    disallowIfSetWhen(when: boolean, error: string | Error, ...columns: any[]): this;
    disallowIfNotSetWhen(when: boolean, error: string | Error, ...columns: any[]): this;
    disallowIfValueWhen(when: boolean, error: string | Error, ...columns: any[]): this;
    disallowIfNoValueWhen(when: boolean, error: string | Error, ...columns: any[]): this;
    disallowAnyOtherSetWhen(when: boolean, error: string | Error, ...columns: any[]): this;
    values(columns: any): this;
    dynamicValues(columns: any): this;
    from(select: IExecutableSelectQuery<any, any, any, any>): this;
    customizeQuery(customization: InsertCustomization<any>): this;
    defaultValues(): this;
    returningLastInsertedId(): this;
    returning(columns: InsertColumns<any>): this;
    projectingOptionalValuesAsNullable(): any;
    returningOneColumn(column: AnyValueSource): this;
    onConflictDoNothing(): this;
    onConflictDoUpdateDynamicSet(columns?: any): any;
    onConflictDoUpdateSet(columns: any): any;
    onConflictDoUpdateSetIfValue(columns: any): any;
    onConflictOn(...columns: AnyValueSource[]): this;
    onConflictOnConstraint(constraint: string | IStringValueSource<any, any> | ITypeSafeStringValueSource<any, any> | RawFragment<any>): this;
    doNothing(): this;
    doUpdateDynamicSet(columns?: any): any;
    doUpdateSet(columns: any): any;
    doUpdateSetIfValue(columns: any): any;
    dynamicWhere(): this;
    where(condition: IBooleanValueSource<any, any> | IIfValueSource<any, any>): this;
    and(condition: IBooleanValueSource<any, any> | IIfValueSource<any, any>): this;
    or(condition: IBooleanValueSource<any, any> | IIfValueSource<any, any>): this;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(_sqlBuilder: HasIsValue, _requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(_sqlBuilder: HasIsValue, _requiredColumns: Set<Column>, _onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(_sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(_sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
