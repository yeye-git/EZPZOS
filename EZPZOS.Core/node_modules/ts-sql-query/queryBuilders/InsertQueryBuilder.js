"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InsertQueryBuilder = void 0;
const SqlBuilder_1 = require("../sqlBuilders/SqlBuilder");
const ITableOrView_1 = require("../utils/ITableOrView");
const Column_1 = require("../utils/Column");
const Column_2 = require("../utils/Column");
const chained_error_1 = require("chained-error");
const attachSource_1 = require("../utils/attachSource");
const symbols_1 = require("../utils/symbols");
const values_1 = require("../expressions/values");
const ITableOrView_2 = require("../utils/ITableOrView");
const ComposeSliptQueryBuilder_1 = require("./ComposeSliptQueryBuilder");
// one implement ommited intentionally to don't confuse TypeScript
class InsertQueryBuilder extends ComposeSliptQueryBuilder_1.ComposeSplitQueryBuilder {
    constructor(sqlBuilder, table) {
        super(sqlBuilder);
        this.__sets = {};
        this.__isMultiple = false;
        this.__withs = [];
        // cache
        this.__query = '';
        this.__params = [];
        this.__table = table;
        (0, ITableOrView_1.__getTableOrViewPrivate)(table).__addWiths(this.__sqlBuilder, this.__withs);
    }
    executeInsert(min, max) {
        this.query();
        const source = new Error('Query executed at');
        (0, ComposeSliptQueryBuilder_1.__setQueryMetadata)(source, this.__params, this.__customization);
        try {
            const idColumn = this.__idColumn;
            const multiple = this.__multiple;
            let result;
            let returningLastInsertedId = !idColumn;
            if (multiple && multiple.length <= 0) {
                if (idColumn) {
                    return this.__sqlBuilder._queryRunner.createResolvedPromise([]);
                }
                else {
                    return this.__sqlBuilder._queryRunner.createResolvedPromise(0);
                }
            }
            else if (!idColumn) {
                result = this.__sqlBuilder._queryRunner.executeInsert(this.__query, this.__params).catch((e) => {
                    throw (0, attachSource_1.attachSource)(new chained_error_1.default(e), source);
                });
            }
            else if (!multiple && !this.__from) {
                result = this.__sqlBuilder._queryRunner.executeInsertReturningLastInsertedId(this.__query, this.__params).then((value) => {
                    if (value === undefined) {
                        value = null;
                    }
                    const idColumnPrivate = (0, Column_2.__getColumnPrivate)(idColumn);
                    const typeAdapter = idColumnPrivate.__typeAdapter;
                    let result;
                    if (typeAdapter) {
                        result = typeAdapter.transformValueFromDB(value, idColumnPrivate.__valueTypeName, this.__sqlBuilder._defaultTypeAdapter);
                    }
                    else {
                        result = this.__sqlBuilder._defaultTypeAdapter.transformValueFromDB(value, idColumnPrivate.__valueTypeName);
                    }
                    if (!this.onConflictDoNothing && (result === null || result === undefined)) {
                        throw new Error('Expected a value as result of the insert returning last inserted id, but null or undefined value was found');
                    }
                    if (this.__isMultiple) {
                        return [result];
                    }
                    else {
                        return result;
                    }
                }).catch((e) => {
                    throw (0, attachSource_1.attachSource)(new chained_error_1.default(e), source);
                });
            }
            else {
                result = this.__sqlBuilder._queryRunner.executeInsertReturningMultipleLastInsertedId(this.__query, this.__params).then((rows) => {
                    const idColumnPrivate = (0, Column_2.__getColumnPrivate)(idColumn);
                    const typeAdapter = idColumnPrivate.__typeAdapter;
                    const columnTypeName = idColumnPrivate.__valueTypeName;
                    const defaultTypeAdapter = this.__sqlBuilder._defaultTypeAdapter;
                    if (typeAdapter) {
                        return rows.map((row, index) => {
                            const result = typeAdapter.transformValueFromDB(row, columnTypeName, defaultTypeAdapter);
                            if (result === null || result === undefined) {
                                throw new Error('Expected a value as result of the insert returning last inserted id, but null or undefined value was found at index ' + index);
                            }
                            return result;
                        });
                    }
                    else {
                        return rows.map((row, index) => {
                            const result = defaultTypeAdapter.transformValueFromDB(row, columnTypeName);
                            if (result === null || result === undefined) {
                                throw new Error('Expected a value as result of the insert returning last inserted id, but null or undefined value was found at index ' + index);
                            }
                            return result;
                        });
                    }
                }).catch((e) => {
                    throw (0, attachSource_1.attachSource)(new chained_error_1.default(e), source);
                });
            }
            if (min !== undefined) {
                result = result.then((result) => {
                    let count;
                    if (Array.isArray(result)) {
                        count = result.length;
                    }
                    else if (returningLastInsertedId) {
                        if (result === null || result === undefined) {
                            count = 0;
                        }
                        else {
                            count = 1;
                        }
                    }
                    else {
                        count = result;
                    }
                    if (count < min) {
                        throw (0, attachSource_1.attachSource)(new Error("The insert operation didn't insert the minimum of " + min + " row(s)"), source);
                    }
                    if (max !== undefined && count > max) {
                        throw (0, attachSource_1.attachSource)(new Error("The insert operation insert more that the maximum of " + max + " row(s)"), source);
                    }
                    return result;
                });
            }
            return result;
        }
        catch (e) {
            throw new chained_error_1.default(e);
        }
    }
    executeInsertNoneOrOne() {
        this.query();
        const source = new Error('Query executed at');
        (0, ComposeSliptQueryBuilder_1.__setQueryMetadata)(source, this.__params, this.__customization);
        try {
            this.__sqlBuilder._resetUnique();
            let result;
            if (this.__oneColumn) {
                result = this.__sqlBuilder._queryRunner.executeInsertReturningOneColumnOneRow(this.__query, this.__params).then((value) => {
                    const valueSource = this.__columns['result'];
                    if (!(0, values_1.isValueSource)(valueSource)) {
                        throw new Error('The result column must be a ValueSource');
                    }
                    if (value === undefined) {
                        return null;
                    }
                    return this.__transformValueFromDB(valueSource, value);
                }).catch((e) => {
                    throw (0, attachSource_1.attachSource)(new chained_error_1.default(e), source);
                });
            }
            else {
                result = this.__sqlBuilder._queryRunner.executeInsertReturningOneRow(this.__query, this.__params).then((row) => {
                    if (row) {
                        return this.__transformRow(row);
                    }
                    else {
                        return null;
                    }
                }).catch((e) => {
                    throw (0, attachSource_1.attachSource)(new chained_error_1.default(e), source);
                });
            }
            return this.__applyCompositions(result, source);
        }
        catch (e) {
            throw new chained_error_1.default(e);
        }
    }
    executeInsertOne() {
        this.query();
        const source = new Error('Query executed at');
        (0, ComposeSliptQueryBuilder_1.__setQueryMetadata)(source, this.__params, this.__customization);
        try {
            this.__sqlBuilder._resetUnique();
            let result;
            if (this.__oneColumn) {
                result = this.__sqlBuilder._queryRunner.executeInsertReturningOneColumnOneRow(this.__query, this.__params).then((value) => {
                    const valueSource = this.__columns['result'];
                    if (!(0, values_1.isValueSource)(valueSource)) {
                        throw new Error('The result column must be a ValueSource');
                    }
                    if (value === undefined) {
                        throw new Error('No result returned by the database');
                    }
                    return this.__transformValueFromDB(valueSource, value);
                }).catch((e) => {
                    throw (0, attachSource_1.attachSource)(new chained_error_1.default(e), source);
                });
            }
            else {
                result = this.__sqlBuilder._queryRunner.executeInsertReturningOneRow(this.__query, this.__params).then((row) => {
                    if (row) {
                        return this.__transformRow(row);
                    }
                    else {
                        throw new Error('No result returned by the database');
                    }
                }).catch((e) => {
                    throw (0, attachSource_1.attachSource)(new chained_error_1.default(e), source);
                });
            }
            return this.__applyCompositions(result, source);
        }
        catch (e) {
            throw new chained_error_1.default(e);
        }
    }
    executeInsertMany(min, max) {
        const source = new Error('Query executed at');
        this.query();
        (0, ComposeSliptQueryBuilder_1.__setQueryMetadata)(source, this.__params, this.__customization);
        try {
            this.__sqlBuilder._resetUnique();
            let result;
            if (this.__oneColumn) {
                result = this.__sqlBuilder._queryRunner.executeInsertReturningOneColumnManyRows(this.__query, this.__params).then((values) => {
                    const valueSource = this.__columns['result'];
                    if (!(0, values_1.isValueSource)(valueSource)) {
                        throw new Error('The result column must be a ValueSource');
                    }
                    return values.map((value) => {
                        if (value === undefined) {
                            value = null;
                        }
                        return this.__transformValueFromDB(valueSource, value);
                    });
                }).catch((e) => {
                    throw (0, attachSource_1.attachSource)(new chained_error_1.default(e), source);
                });
            }
            else {
                result = this.__sqlBuilder._queryRunner.executeInsertReturningManyRows(this.__query, this.__params).then((rows) => {
                    return rows.map((row, index) => {
                        return this.__transformRow(row, index);
                    });
                }).catch((e) => {
                    throw (0, attachSource_1.attachSource)(new chained_error_1.default(e), source);
                });
            }
            if (min !== undefined) {
                result = result.then((rows) => {
                    const count = rows.length;
                    if (count < min) {
                        throw (0, attachSource_1.attachSource)(new Error("The insert operation didn't insert the minimum of " + min + " row(s)"), source);
                    }
                    if (max !== undefined && count > max) {
                        throw (0, attachSource_1.attachSource)(new Error("The insert operation insert more that the maximum of " + max + " row(s)"), source);
                    }
                    return rows;
                });
            }
            return this.__applyCompositions(result, source);
        }
        catch (e) {
            throw new chained_error_1.default(e);
        }
    }
    query() {
        if (this.__query) {
            return this.__query;
        }
        try {
            if (this.__from) {
                this.__query = this.__sqlBuilder._buildInsertFromSelect(this, this.__params);
            }
            else if (this.__multiple) {
                this.__query = this.__sqlBuilder._buildInsertMultiple(this, this.__params);
            }
            else if (this.__sets === DEFAULT_VALUES) {
                this.__query = this.__sqlBuilder._buildInsertDefaultValues(this, this.__params);
            }
            else {
                this.__query = this.__sqlBuilder._buildInsert(this, this.__params);
            }
        }
        catch (e) {
            throw new chained_error_1.default(e);
        }
        return this.__query;
    }
    params() {
        if (!this.__query) {
            this.query();
        }
        return this.__params;
    }
    __toSql(_sqlBuilder, params) {
        if (this.__from) {
            return this.__sqlBuilder._buildInsertFromSelect(this, params);
        }
        else if (this.__multiple) {
            return this.__sqlBuilder._buildInsertMultiple(this, params);
        }
        else if (this.__sets === DEFAULT_VALUES) {
            return this.__sqlBuilder._buildInsertDefaultValues(this, params);
        }
        else {
            return this.__sqlBuilder._buildInsert(this, params);
        }
    }
    __toSqlForCondition(sqlBuilder, params) {
        return this.__toSql(sqlBuilder, params);
    }
    shapedAs(shape) {
        this.__query = '';
        this.__shape = shape;
        return this;
    }
    extendShape(extendShape) {
        this.__query = '';
        let shape;
        if (this.__onConflictUpdateSets) {
            shape = this.__onConflictUpdateShape;
        }
        else {
            shape = this.__shape;
        }
        if (!shape) {
            if (this.__onConflictUpdateSets) {
                this.__onConflictUpdateShape = extendShape;
            }
            else {
                this.__shape = extendShape;
            }
            return this;
        }
        const properties = Object.getOwnPropertyNames(extendShape);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            const value = extendShape[property];
            // It will review only the properties that can be used as shape, skiiping the other one to allow more complex usages
            if (typeof value === 'string' || (0, Column_1.isColumn)(value)) {
                const currentShapeValue = shape[property];
                if (typeof currentShapeValue === 'string' || (0, Column_1.isColumn)(value)) {
                    throw new Error('You cannot override the previously defined shape property with name ' + property);
                }
            }
        }
        shape = { ...shape, ...extendShape };
        if (this.__onConflictUpdateSets) {
            this.__onConflictUpdateShape = shape;
        }
        else {
            this.__shape = shape;
        }
        return this;
    }
    dynamicSet(columns) {
        if (columns) {
            return this.set(columns);
        }
        this.__query = '';
        return this;
    }
    __getSetsForMultipleInsert() {
        const multiple = this.__multiple;
        const sets = this.__sets;
        if (this.__multipleAlreadyCopied) {
            return multiple || [sets];
        }
        if (!multiple) {
            const newSets = { ...sets };
            const result = [newSets];
            this.__sets = newSets;
            this.__multipleAlreadyCopied = true;
            return result;
        }
        const result = [];
        for (let i = 0, length = multiple.length; i < length; i++) {
            result.push({ ...multiple[i] });
        }
        this.__multiple = result;
        this.__multipleAlreadyCopied = true;
        return result;
    }
    set(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets;
        let shape;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
            shape = this.__onConflictUpdateShape;
            this.__valuesForInsert = this.__valuesForInsert || this.__getValuesForInsertOfColumns(columns);
        }
        else {
            sets = this.__sets;
            shape = this.__shape;
        }
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            sets[property] = value;
        }
        return this;
    }
    setIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets;
        let shape;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
            shape = this.__onConflictUpdateShape;
            this.__valuesForInsert = this.__valuesForInsert || this.__getValuesForInsertOfColumns(columns);
        }
        else {
            sets = this.__sets;
            shape = this.__shape;
        }
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            sets[property] = value;
        }
        return this;
    }
    setIfSet(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets;
        let shape;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
            shape = this.__onConflictUpdateShape;
            this.__valuesForInsert = this.__valuesForInsert || this.__getValuesForInsertOfColumns(columns);
        }
        else {
            sets = this.__sets;
            shape = this.__shape;
        }
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            if (!(property in sets)) {
                continue;
            }
            const value = columns[property];
            sets[property] = value;
        }
        return this;
    }
    setIfSetIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets;
        let shape;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
            shape = this.__onConflictUpdateShape;
            this.__valuesForInsert = this.__valuesForInsert || this.__getValuesForInsertOfColumns(columns);
        }
        else {
            sets = this.__sets;
            shape = this.__shape;
        }
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            if (!(property in sets)) {
                continue;
            }
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            sets[property] = value;
        }
        return this;
    }
    setIfNotSet(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets;
        let shape;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
            shape = this.__onConflictUpdateShape;
            this.__valuesForInsert = this.__valuesForInsert || this.__getValuesForInsertOfColumns(columns);
        }
        else {
            sets = this.__sets;
            shape = this.__shape;
        }
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            if (property in sets) {
                continue;
            }
            const value = columns[property];
            sets[property] = value;
        }
        return this;
    }
    setIfNotSetIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets;
        let shape;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
            shape = this.__onConflictUpdateShape;
            this.__valuesForInsert = this.__valuesForInsert || this.__getValuesForInsertOfColumns(columns);
        }
        else {
            sets = this.__sets;
            shape = this.__shape;
        }
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            if (property in sets) {
                continue;
            }
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            sets[property] = value;
        }
        return this;
    }
    ignoreIfSet(...columns) {
        this.__query = '';
        let sets;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
        }
        else if (this.__multiple) {
            const multiple = this.__getSetsForMultipleInsert();
            for (let j = 0, length = multiple.length; j < length; j++) {
                const item = multiple[j];
                for (let i = 0, length = columns.length; i < length; i++) {
                    let column = columns[i];
                    delete item[column];
                }
            }
            return this;
        }
        else {
            sets = this.__sets;
        }
        for (let i = 0, length = columns.length; i < length; i++) {
            let column = columns[i];
            delete sets[column];
        }
        return this;
    }
    keepOnly(...columns) {
        this.__query = '';
        let sets;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
        }
        else if (this.__multiple) {
            const multiple = this.__getSetsForMultipleInsert();
            const allow = {};
            for (let i = 0, length = columns.length; i < length; i++) {
                let column = columns[i];
                allow[column] = true;
            }
            for (let j = 0, length = multiple.length; j < length; j++) {
                const item = multiple[j];
                const properties = Object.getOwnPropertyNames(item);
                for (let i = 0, length = properties.length; i < length; i++) {
                    const property = properties[i];
                    if (!allow[property]) {
                        delete item[property];
                    }
                }
            }
            return this;
        }
        else {
            sets = this.__sets;
        }
        const allow = {};
        for (let i = 0, length = columns.length; i < length; i++) {
            let column = columns[i];
            allow[column] = true;
        }
        const properties = Object.getOwnPropertyNames(sets);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (!allow[property]) {
                delete sets[property];
            }
        }
        return this;
    }
    setIfHasValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets;
        let shape;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
            shape = this.__onConflictUpdateShape;
            this.__valuesForInsert = this.__valuesForInsert || this.__getValuesForInsertOfColumns(columns);
        }
        else {
            sets = this.__sets;
            shape = this.__shape;
        }
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            if (!this.__sqlBuilder._isValue(sets[property])) {
                continue;
            }
            const value = columns[property];
            sets[property] = value;
        }
        return this;
    }
    setIfHasValueIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets;
        let shape;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
            shape = this.__onConflictUpdateShape;
            this.__valuesForInsert = this.__valuesForInsert || this.__getValuesForInsertOfColumns(columns);
        }
        else {
            sets = this.__sets;
            shape = this.__shape;
        }
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            if (!this.__sqlBuilder._isValue(sets[property])) {
                continue;
            }
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            sets[property] = value;
        }
        return this;
    }
    setIfHasNoValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets;
        let shape;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
            shape = this.__onConflictUpdateShape;
            this.__valuesForInsert = this.__valuesForInsert || this.__getValuesForInsertOfColumns(columns);
        }
        else {
            sets = this.__sets;
            shape = this.__shape;
        }
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            if (this.__sqlBuilder._isValue(sets[property])) {
                continue;
            }
            const value = columns[property];
            sets[property] = value;
        }
        return this;
    }
    setIfHasNoValueIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets;
        let shape;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
            shape = this.__onConflictUpdateShape;
            this.__valuesForInsert = this.__valuesForInsert || this.__getValuesForInsertOfColumns(columns);
        }
        else {
            sets = this.__sets;
            shape = this.__shape;
        }
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            if (this.__sqlBuilder._isValue(sets[property])) {
                continue;
            }
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            sets[property] = value;
        }
        return this;
    }
    ignoreIfHasValue(...columns) {
        this.__query = '';
        let sets;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
        }
        else if (this.__multiple) {
            const multiple = this.__getSetsForMultipleInsert();
            for (let j = 0, length = multiple.length; j < length; j++) {
                const item = multiple[j];
                for (let i = 0, length = columns.length; i < length; i++) {
                    let column = columns[i];
                    if (!this.__sqlBuilder._isValue(item[column])) {
                        continue;
                    }
                    delete item[column];
                }
            }
            return this;
        }
        else {
            sets = this.__sets;
        }
        for (let i = 0, length = columns.length; i < length; i++) {
            let column = columns[i];
            if (!this.__sqlBuilder._isValue(sets[column])) {
                continue;
            }
            delete sets[column];
        }
        return this;
    }
    ignoreIfHasNoValue(...columns) {
        this.__query = '';
        let sets;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
        }
        else if (this.__multiple) {
            const multiple = this.__getSetsForMultipleInsert();
            for (let j = 0, length = multiple.length; j < length; j++) {
                const item = multiple[j];
                for (let i = 0, length = columns.length; i < length; i++) {
                    let column = columns[i];
                    if (this.__sqlBuilder._isValue(item[column])) {
                        continue;
                    }
                    delete item[column];
                }
            }
            return this;
        }
        else {
            sets = this.__sets;
        }
        for (let i = 0, length = columns.length; i < length; i++) {
            let column = columns[i];
            if (this.__sqlBuilder._isValue(sets[column])) {
                continue;
            }
            delete sets[column];
        }
        return this;
    }
    ignoreAnySetWithNoValue() {
        this.__query = '';
        let sets;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
        }
        else if (this.__multiple) {
            const multiple = this.__getSetsForMultipleInsert();
            for (let j = 0, length = multiple.length; j < length; j++) {
                const item = multiple[j];
                const properties = Object.getOwnPropertyNames(item);
                for (let i = 0, length = properties.length; i < length; i++) {
                    const property = properties[i];
                    if (this.__sqlBuilder._isValue(item[property])) {
                        continue;
                    }
                    delete item[property];
                }
            }
            return this;
        }
        else {
            sets = this.__sets;
        }
        const properties = Object.getOwnPropertyNames(sets);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (this.__sqlBuilder._isValue(sets[property])) {
                continue;
            }
            delete sets[property];
        }
        return this;
    }
    setForAll(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        const sets = this.__getSetsForMultipleInsert();
        const shape = this.__shape;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            for (let j = 0, length = sets.length; j < length; j++) {
                sets[j][property] = value;
            }
        }
        return this;
    }
    setForAllIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        const sets = this.__getSetsForMultipleInsert();
        const shape = this.__shape;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            for (let j = 0, length = sets.length; j < length; j++) {
                const item = sets[j];
                item[property] = value;
            }
        }
        return this;
    }
    setForAllIfSet(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        const sets = this.__getSetsForMultipleInsert();
        const shape = this.__shape;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            for (let j = 0, length = sets.length; j < length; j++) {
                const item = sets[j];
                if (!(property in item)) {
                    continue;
                }
                item[property] = value;
            }
        }
        return this;
    }
    setForAllIfSetIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        const sets = this.__getSetsForMultipleInsert();
        const shape = this.__shape;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            for (let j = 0, length = sets.length; j < length; j++) {
                const item = sets[j];
                if (!(property in item)) {
                    continue;
                }
                item[property] = value;
            }
        }
        return this;
    }
    setForAllIfNotSet(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        const sets = this.__getSetsForMultipleInsert();
        const shape = this.__shape;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            for (let j = 0, length = sets.length; j < length; j++) {
                const item = sets[j];
                if (property in item) {
                    continue;
                }
                item[property] = value;
            }
        }
        return this;
    }
    setForAllIfNotSetIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        const sets = this.__getSetsForMultipleInsert();
        const shape = this.__shape;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            for (let j = 0, length = sets.length; j < length; j++) {
                const item = sets[j];
                if (property in item) {
                    continue;
                }
                item[property] = value;
            }
        }
        return this;
    }
    setForAllIfHasValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        const sets = this.__getSetsForMultipleInsert();
        const shape = this.__shape;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            for (let j = 0, length = sets.length; j < length; j++) {
                const item = sets[j];
                if (!this.__sqlBuilder._isValue(item[property])) {
                    continue;
                }
                item[property] = value;
            }
        }
        return this;
    }
    setForAllIfHasValueIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        const sets = this.__getSetsForMultipleInsert();
        const shape = this.__shape;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            for (let j = 0, length = sets.length; j < length; j++) {
                const item = sets[j];
                if (!this.__sqlBuilder._isValue(item[property])) {
                    continue;
                }
                item[property] = value;
            }
        }
        return this;
    }
    setForAllIfHasNoValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        const sets = this.__getSetsForMultipleInsert();
        const shape = this.__shape;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            for (let j = 0, length = sets.length; j < length; j++) {
                const item = sets[j];
                if (this.__sqlBuilder._isValue(item[property])) {
                    continue;
                }
                item[property] = value;
            }
        }
        return this;
    }
    setForAllIfHasNoValueIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        const sets = this.__getSetsForMultipleInsert();
        const shape = this.__shape;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            for (let j = 0, length = sets.length; j < length; j++) {
                const item = sets[j];
                if (this.__sqlBuilder._isValue(item[property])) {
                    continue;
                }
                item[property] = value;
            }
        }
        return this;
    }
    disallowIfSet(error, ...columns) {
        this.__query = '';
        let sets;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
        }
        else if (this.__multiple) {
            const multiple = this.__getSetsForMultipleInsert();
            for (let j = 0, length = multiple.length; j < length; j++) {
                const item = multiple[j];
                for (let i = 0, length = columns.length; i < length; i++) {
                    let column = columns[i];
                    if (column in item) {
                        if (typeof error === 'string') {
                            error = new Error(error);
                        }
                        error['disallowedPropery'] = column;
                        error['disallowedIndex'] = j;
                        throw error;
                    }
                }
            }
            return this;
        }
        else {
            sets = this.__sets;
        }
        for (let i = 0, length = columns.length; i < length; i++) {
            let column = columns[i];
            if (column in sets) {
                if (typeof error === 'string') {
                    error = new Error(error);
                }
                error['disallowedPropery'] = column;
                throw error;
            }
        }
        return this;
    }
    disallowIfNotSet(error, ...columns) {
        this.__query = '';
        let sets;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
        }
        else if (this.__multiple) {
            const multiple = this.__getSetsForMultipleInsert();
            for (let j = 0, length = multiple.length; j < length; j++) {
                const item = multiple[j];
                for (let i = 0, length = columns.length; i < length; i++) {
                    let column = columns[i];
                    if (!(column in item)) {
                        if (typeof error === 'string') {
                            error = new Error(error);
                        }
                        error['disallowedPropery'] = column;
                        error['disallowedIndex'] = j;
                        throw error;
                    }
                }
            }
            return this;
        }
        else {
            sets = this.__sets;
        }
        for (let i = 0, length = columns.length; i < length; i++) {
            let column = columns[i];
            if (!(column in sets)) {
                if (typeof error === 'string') {
                    error = new Error(error);
                }
                error['disallowedPropery'] = column;
                throw error;
            }
        }
        return this;
    }
    disallowIfValue(error, ...columns) {
        this.__query = '';
        let sets;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
        }
        else if (this.__multiple) {
            const multiple = this.__getSetsForMultipleInsert();
            for (let j = 0, length = multiple.length; j < length; j++) {
                const item = multiple[j];
                for (let i = 0, length = columns.length; i < length; i++) {
                    let column = columns[i];
                    if (this.__sqlBuilder._isValue(item[column])) {
                        if (typeof error === 'string') {
                            error = new Error(error);
                        }
                        error['disallowedPropery'] = column;
                        error['disallowedIndex'] = j;
                        throw error;
                    }
                }
            }
            return this;
        }
        else {
            sets = this.__sets;
        }
        for (let i = 0, length = columns.length; i < length; i++) {
            let column = columns[i];
            if (this.__sqlBuilder._isValue(sets[column])) {
                if (typeof error === 'string') {
                    error = new Error(error);
                }
                error['disallowedPropery'] = column;
                throw error;
            }
        }
        return this;
    }
    disallowIfNoValue(error, ...columns) {
        this.__query = '';
        let sets;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
        }
        else if (this.__multiple) {
            const multiple = this.__getSetsForMultipleInsert();
            for (let j = 0, length = multiple.length; j < length; j++) {
                const item = multiple[j];
                for (let i = 0, length = columns.length; i < length; i++) {
                    let column = columns[i];
                    if (!this.__sqlBuilder._isValue(item[column])) {
                        if (typeof error === 'string') {
                            error = new Error(error);
                        }
                        error['disallowedPropery'] = column;
                        error['disallowedIndex'] = j;
                        throw error;
                    }
                }
            }
            return this;
        }
        else {
            sets = this.__sets;
        }
        for (let i = 0, length = columns.length; i < length; i++) {
            let column = columns[i];
            if (!this.__sqlBuilder._isValue(sets[column])) {
                if (typeof error === 'string') {
                    error = new Error(error);
                }
                error['disallowedPropery'] = column;
                throw error;
            }
        }
        return this;
    }
    disallowAnyOtherSet(error, ...columns) {
        this.__query = '';
        const allowed = {};
        for (let i = 0, length = columns.length; i < length; i++) {
            let column = columns[i];
            allowed[column] = true;
        }
        let shape;
        let sets;
        if (this.__onConflictUpdateSets) {
            sets = this.__onConflictUpdateSets;
            shape = this.__onConflictUpdateShape || this.__table;
        }
        else if (this.__multiple) {
            shape = this.__shape || this.__table;
            const multiple = this.__getSetsForMultipleInsert();
            for (let j = 0, length = multiple.length; j < length; j++) {
                const item = multiple[j];
                const properties = Object.getOwnPropertyNames(item);
                for (let i = 0, length = properties.length; i < length; i++) {
                    const property = properties[i];
                    if (!(property in shape)) {
                        // This is not a property that will be included in the update
                        // Ingoring it allow more complex operations
                        continue;
                    }
                    if (!allowed[property]) {
                        if (typeof error === 'string') {
                            error = new Error(error);
                        }
                        error['disallowedPropery'] = property;
                        error['disallowedIndex'] = j;
                        throw error;
                    }
                    else {
                        console.log('b');
                    }
                }
            }
            return this;
        }
        else {
            shape = this.__shape || this.__table;
            sets = this.__sets;
        }
        const properties = Object.getOwnPropertyNames(sets);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (!(property in shape)) {
                // This is not a property that will be included in the update
                // Ingoring it allow more complex operations
                continue;
            }
            if (!allowed[property]) {
                if (typeof error === 'string') {
                    error = new Error(error);
                }
                error['disallowedPropery'] = property;
                throw error;
            }
        }
        return this;
    }
    setWhen(when, columns) {
        if (when) {
            return this.set(columns);
        }
        return this;
    }
    setIfValueWhen(when, columns) {
        if (when) {
            return this.setIfValue(columns);
        }
        return this;
    }
    setIfSetWhen(when, columns) {
        if (when) {
            return this.setIfSet(columns);
        }
        return this;
    }
    setIfSetIfValueWhen(when, columns) {
        if (when) {
            return this.setIfSetIfValue(columns);
        }
        return this;
    }
    setIfNotSetWhen(when, columns) {
        if (when) {
            return this.setIfNotSet(columns);
        }
        return this;
    }
    setIfNotSetIfValueWhen(when, columns) {
        if (when) {
            return this.setIfNotSetIfValue(columns);
        }
        return this;
    }
    ignoreIfSetWhen(when, ...columns) {
        if (when) {
            return this.ignoreIfSet(...columns);
        }
        return this;
    }
    keepOnlyWhen(when, ...columns) {
        if (when) {
            return this.keepOnly(...columns);
        }
        return this;
    }
    setIfHasValueWhen(when, columns) {
        if (when) {
            return this.setIfHasValue(columns);
        }
        return this;
    }
    setIfHasValueIfValueWhen(when, columns) {
        if (when) {
            return this.setIfHasValueIfValue(columns);
        }
        return this;
    }
    setIfHasNoValueWhen(when, columns) {
        if (when) {
            return this.setIfHasNoValue(columns);
        }
        return this;
    }
    setIfHasNoValueIfValueWhen(when, columns) {
        if (when) {
            return this.setIfHasNoValueIfValue(columns);
        }
        return this;
    }
    ignoreIfHasValueWhen(when, ...columns) {
        if (when) {
            return this.ignoreIfHasValue(...columns);
        }
        return this;
    }
    ignoreIfHasNoValueWhen(when, ...columns) {
        if (when) {
            return this.ignoreIfHasValue(...columns);
        }
        return this;
    }
    ignoreAnySetWithNoValueWhen(when) {
        if (when) {
            return this.ignoreAnySetWithNoValue();
        }
        return this;
    }
    setForAllWhen(when, columns) {
        if (when) {
            return this.setForAll(columns);
        }
        return this;
    }
    setForAllIfValueWhen(when, columns) {
        if (when) {
            return this.setForAllIfValue(columns);
        }
        return this;
    }
    setForAllIfSetWhen(when, columns) {
        if (when) {
            return this.setForAllIfSet(columns);
        }
        return this;
    }
    setForAllIfSetIfValueWhen(when, columns) {
        if (when) {
            return this.setForAllIfSetIfValue(columns);
        }
        return this;
    }
    setForAllIfNotSetWhen(when, columns) {
        if (when) {
            return this.setForAllIfNotSet(columns);
        }
        return this;
    }
    setForAllIfNotSetIfValueWhen(when, columns) {
        if (when) {
            return this.setForAllIfNotSetIfValue(columns);
        }
        return this;
    }
    setForAllIfHasValueWhen(when, columns) {
        if (when) {
            return this.setForAllIfHasValue(columns);
        }
        return this;
    }
    setForAllIfHasValueIfValueWhen(when, columns) {
        if (when) {
            return this.setForAllIfHasValueIfValue(columns);
        }
        return this;
    }
    setForAllIfHasNoValueWhen(when, columns) {
        if (when) {
            return this.setForAllIfHasNoValue(columns);
        }
        return this;
    }
    setForAllIfHasNoValueIfValueWhen(when, columns) {
        if (when) {
            return this.setForAllIfHasNoValueIfValue(columns);
        }
        return this;
    }
    disallowIfSetWhen(when, error, ...columns) {
        if (when) {
            return this.disallowIfSet(error, ...columns);
        }
        return this;
    }
    disallowIfNotSetWhen(when, error, ...columns) {
        if (when) {
            return this.disallowIfNotSet(error, ...columns);
        }
        return this;
    }
    disallowIfValueWhen(when, error, ...columns) {
        if (when) {
            return this.disallowIfValue(error, ...columns);
        }
        return this;
    }
    disallowIfNoValueWhen(when, error, ...columns) {
        if (when) {
            return this.disallowIfNoValue(error, ...columns);
        }
        return this;
    }
    disallowAnyOtherSetWhen(when, error, ...columns) {
        if (when) {
            return this.disallowAnyOtherSet(error, ...columns);
        }
        return this;
    }
    values(columns) {
        if (Array.isArray(columns)) {
            this.__isMultiple = true;
            if (columns.length == 1) {
                return this.set(columns[0]);
            }
            this.__multiple = columns;
            return this;
        }
        else {
            return this.set(columns);
        }
    }
    dynamicValues(columns) {
        return this.values(columns);
    }
    from(select) {
        this.__from = select;
        (0, ITableOrView_2.__addWiths)(select, this.__sqlBuilder, this.__withs);
        return this;
    }
    customizeQuery(customization) {
        this.__customization = customization;
        (0, ITableOrView_2.__addWiths)(customization.beforeQuery, this.__sqlBuilder, this.__withs);
        (0, ITableOrView_2.__addWiths)(customization.afterInsertKeyword, this.__sqlBuilder, this.__withs);
        (0, ITableOrView_2.__addWiths)(customization.afterQuery, this.__sqlBuilder, this.__withs);
        return this;
    }
    defaultValues() {
        this.__query = '';
        this.__sets = DEFAULT_VALUES;
        return this;
    }
    returningLastInsertedId() {
        this.__query = '';
        const table = this.__table;
        for (var columnName in table) {
            const column = (0, Column_2.__getColumnOfObject)(table, columnName);
            if (!column) {
                continue;
            }
            const columnPrivate = (0, Column_2.__getColumnPrivate)(column);
            if (!columnPrivate.__isAutogeneratedPrimaryKey) {
                continue;
            }
            if (this.__idColumn) {
                throw new Error('In order to call executeInsertReturningLastInsertedId method the table must have defined only one autogenerated primary key column');
            }
            this.__idColumn = column;
        }
        if (!this.__idColumn) {
            throw new Error('In order to call executeInsertReturningLastInsertedId method the table must have defined one autogenerated primary key column');
        }
        return this;
    }
    returning(columns) {
        this.__query = '';
        this.__columns = columns;
        this.__registerTableOrViewWithOfColumns(columns, this.__withs);
        return this;
    }
    projectingOptionalValuesAsNullable() {
        this.__projectOptionalValuesAsNullable = true;
        return this;
    }
    returningOneColumn(column) {
        this.__query = '';
        this.__oneColumn = true;
        this.__columns = { 'result': column };
        (0, values_1.__getValueSourcePrivate)(column).__addWiths(this.__sqlBuilder, this.__withs);
        return this;
    }
    onConflictDoNothing() {
        this.__query = '';
        this.__onConflictDoNothing = true;
        return this;
    }
    onConflictDoUpdateDynamicSet(columns) {
        if (columns) {
            this.onConflictDoUpdateSet(columns);
        }
        this.__query = '';
        if (this.__onConflictUpdateSets) {
            throw new Error('Illegal state');
        }
        this.__onConflictUpdateSets = {};
        if (this.__shape) {
            this.__onConflictUpdateShape = this.__shape;
        }
        return this;
    }
    onConflictDoUpdateSet(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        if (this.__onConflictUpdateSets) {
            throw new Error('Illegal state');
        }
        this.__onConflictUpdateSets = {};
        const shape = this.__shape;
        if (shape) {
            this.__onConflictUpdateShape = shape;
        }
        let sets = this.__onConflictUpdateSets;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            sets[property] = value;
        }
        this.__valuesForInsert = this.__valuesForInsert || this.__getValuesForInsertOfColumns(columns);
        return this;
    }
    onConflictDoUpdateSetIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        if (this.__onConflictUpdateSets) {
            throw new Error('Illegal state');
        }
        this.__onConflictUpdateSets = {};
        const shape = this.__shape;
        if (shape) {
            this.__onConflictUpdateShape = shape;
        }
        let sets = this.__onConflictUpdateSets;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            sets[property] = value;
        }
        this.__valuesForInsert = this.__valuesForInsert || this.__getValuesForInsertOfColumns(columns);
        return this;
    }
    onConflictOn(...columns) {
        this.__query = '';
        if (this.__onConflictOnColumns) {
            throw new Error('Illegal state');
        }
        this.__onConflictOnColumns = columns;
        for (let i = 0, length = columns.length; i < length; i++) {
            (0, values_1.__getValueSourcePrivate)(columns[i]).__addWiths(this.__sqlBuilder, this.__withs);
        }
        return this;
    }
    onConflictOnConstraint(constraint) {
        this.__query = '';
        if (this.__onConflictOnConstraint) {
            throw new Error('Illegal state');
        }
        this.__onConflictOnConstraint = constraint;
        (0, ITableOrView_2.__addWiths)(constraint, this.__sqlBuilder, this.__withs);
        return this;
    }
    doNothing() {
        this.__query = '';
        this.__onConflictDoNothing = true;
        return this;
    }
    doUpdateDynamicSet(columns) {
        if (columns) {
            this.doUpdateSet(columns);
        }
        this.__query = '';
        if (this.__onConflictUpdateSets) {
            throw new Error('Illegal state');
        }
        this.__onConflictUpdateSets = {};
        if (this.__shape) {
            this.__onConflictUpdateShape = this.__shape;
        }
        return this;
    }
    doUpdateSet(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        if (this.__onConflictUpdateSets) {
            throw new Error('Illegal state');
        }
        this.__onConflictUpdateSets = {};
        const shape = this.__shape;
        if (shape) {
            this.__onConflictUpdateShape = shape;
        }
        let sets = this.__onConflictUpdateSets;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            sets[property] = value;
        }
        this.__valuesForInsert = this.__valuesForInsert || this.__getValuesForInsertOfColumns(columns);
        return this;
    }
    doUpdateSetIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        if (this.__onConflictUpdateSets) {
            throw new Error('Illegal state');
        }
        this.__onConflictUpdateSets = {};
        const shape = this.__shape;
        if (shape) {
            this.__onConflictUpdateShape = shape;
        }
        let sets = this.__onConflictUpdateSets;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (shape && !(property in shape)) {
                // property not in the shape
                continue;
            }
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            sets[property] = value;
        }
        this.__valuesForInsert = this.__valuesForInsert || this.__getValuesForInsertOfColumns(columns);
        return this;
    }
    dynamicWhere() {
        this.__query = '';
        return this;
    }
    where(condition) {
        this.__query = '';
        if (this.__onConflictUpdateSets) {
            if (this.__onConflictUpdateWhere) {
                throw new Error('Illegal state');
            }
            this.__onConflictUpdateWhere = (0, values_1.asAlwaysIfValueSource)(condition);
            const conditionPrivate = (0, values_1.__getValueSourcePrivate)(condition);
            conditionPrivate.__addWiths(this.__sqlBuilder, this.__withs);
            this.__valuesForInsert = this.__valuesForInsert || conditionPrivate.__getValuesForInsert(this.__sqlBuilder);
        }
        else if (this.__onConflictOnColumns) {
            if (this.__onConflictOnColumnsWhere) {
                throw new Error('Illegal state');
            }
            this.__onConflictOnColumnsWhere = (0, values_1.asAlwaysIfValueSource)(condition);
            (0, values_1.__getValueSourcePrivate)(condition).__addWiths(this.__sqlBuilder, this.__withs);
        }
        else {
            throw new Error('Illegal state');
        }
        return this;
    }
    and(condition) {
        this.__query = '';
        if (this.__onConflictUpdateSets) {
            if (!this.__onConflictUpdateWhere) {
                this.__onConflictUpdateWhere = (0, values_1.asAlwaysIfValueSource)(condition);
            }
            else {
                this.__onConflictUpdateWhere = this.__onConflictUpdateWhere.and((0, values_1.asAlwaysIfValueSource)(condition));
            }
            const conditionPrivate = (0, values_1.__getValueSourcePrivate)(condition);
            conditionPrivate.__addWiths(this.__sqlBuilder, this.__withs);
            this.__valuesForInsert = this.__valuesForInsert || conditionPrivate.__getValuesForInsert(this.__sqlBuilder);
        }
        else if (this.__onConflictOnColumns) {
            if (!this.__onConflictOnColumnsWhere) {
                this.__onConflictOnColumnsWhere = (0, values_1.asAlwaysIfValueSource)(condition);
            }
            else {
                this.__onConflictOnColumnsWhere = this.__onConflictOnColumnsWhere.and((0, values_1.asAlwaysIfValueSource)(condition));
            }
            (0, values_1.__getValueSourcePrivate)(condition).__addWiths(this.__sqlBuilder, this.__withs);
        }
        else {
            throw new Error('Illegal state');
        }
        return this;
    }
    or(condition) {
        this.__query = '';
        if (this.__onConflictUpdateSets) {
            if (!this.__onConflictUpdateWhere) {
                this.__onConflictUpdateWhere = (0, values_1.asAlwaysIfValueSource)(condition);
            }
            else {
                this.__onConflictUpdateWhere = this.__onConflictUpdateWhere.or((0, values_1.asAlwaysIfValueSource)(condition));
            }
            const conditionPrivate = (0, values_1.__getValueSourcePrivate)(condition);
            conditionPrivate.__addWiths(this.__sqlBuilder, this.__withs);
            this.__valuesForInsert = this.__valuesForInsert || conditionPrivate.__getValuesForInsert(this.__sqlBuilder);
        }
        else if (this.__onConflictOnColumns) {
            if (!this.__onConflictOnColumnsWhere) {
                this.__onConflictOnColumnsWhere = (0, values_1.asAlwaysIfValueSource)(condition);
            }
            else {
                this.__onConflictOnColumnsWhere = this.__onConflictOnColumnsWhere.or((0, values_1.asAlwaysIfValueSource)(condition));
            }
            (0, values_1.__getValueSourcePrivate)(condition).__addWiths(this.__sqlBuilder, this.__withs);
        }
        else {
            throw new Error('Illegal state');
        }
        return this;
    }
    __addWiths(sqlBuilder, withs) {
        const withViews = this.__withs;
        for (let i = 0, length = withViews.length; i < length; i++) {
            const withView = withViews[i];
            (0, ITableOrView_1.__getTableOrViewPrivate)(withView).__addWiths(sqlBuilder, withs);
        }
    }
    __registerTableOrView(_sqlBuilder, _requiredTablesOrViews) {
        // do nothing because it is not possible to add external dependency
    }
    __registerRequiredColumn(_sqlBuilder, _requiredColumns, _onlyForTablesOrViews) {
        // do nothing because it is not possible to add external dependency
    }
    __getOldValues(_sqlBuilder) {
        // old values fake table is not possible to be used here
        return undefined;
    }
    __getValuesForInsert(_sqlBuilder) {
        // values for insert fake table is not possible to be used here
        return undefined;
    }
    __isAllowed(sqlBuilder) {
        let result = (0, ITableOrView_1.__getTableOrViewPrivate)(this.__table).__isAllowed(sqlBuilder);
        if (!result) {
            return false;
        }
        result = (0, ITableOrView_1.__isAllowed)(this.__from, sqlBuilder);
        if (!result) {
            return false;
        }
        const sets = this.__sets;
        for (let prop in sets) {
            const set = sets[prop];
            const result = (0, ITableOrView_1.__isAllowed)(set, sqlBuilder);
            if (!result) {
                return false;
            }
        }
        const multiple = this.__multiple;
        if (multiple) {
            for (let i = 0, length = multiple.length; i < length; i++) {
                const sets = multiple[i];
                for (let prop in sets) {
                    const set = sets[prop];
                    const result = (0, ITableOrView_1.__isAllowed)(set, sqlBuilder);
                    if (!result) {
                        return false;
                    }
                }
            }
        }
        if (this.__columns) {
            result = (0, SqlBuilder_1.isAllowedQueryColumns)(this.__columns, sqlBuilder);
            if (!result) {
                return false;
            }
        }
        result = (0, ITableOrView_1.__isAllowed)(this.__onConflictOnConstraint, sqlBuilder);
        if (!result) {
            return false;
        }
        result = (0, ITableOrView_1.__isAllowed)(this.__onConflictOnColumns, sqlBuilder);
        if (!result) {
            return false;
        }
        result = (0, ITableOrView_1.__isAllowed)(this.__onConflictOnColumnsWhere, sqlBuilder);
        if (!result) {
            return false;
        }
        const updateSets = this.__sets;
        for (let prop in updateSets) {
            const set = updateSets[prop];
            const result = (0, ITableOrView_1.__isAllowed)(set, sqlBuilder);
            if (!result) {
                return false;
            }
        }
        result = (0, ITableOrView_1.__isAllowed)(this.__onConflictUpdateWhere, sqlBuilder);
        if (!result) {
            return false;
        }
        if (this.__customization) {
            result = (0, ITableOrView_1.__isAllowed)(this.__customization.beforeQuery, sqlBuilder);
            if (!result) {
                return false;
            }
            result = (0, ITableOrView_1.__isAllowed)(this.__customization.afterInsertKeyword, sqlBuilder);
            if (!result) {
                return false;
            }
            result = (0, ITableOrView_1.__isAllowed)(this.__customization.afterQuery, sqlBuilder);
            if (!result) {
                return false;
            }
        }
        return true;
    }
}
exports.InsertQueryBuilder = InsertQueryBuilder;
const DEFAULT_VALUES = {};
