"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FragmentFunctionBuilderMaybeOptional = exports.FragmentFunctionBuilderIfValue = exports.FragmentFunctionBuilder = exports.FragmentQueryBuilder = void 0;
const values_1 = require("../expressions/values");
const ValueSourceImpl_1 = require("../internal/ValueSourceImpl");
class FragmentQueryBuilder {
    constructor(type, typeName, optionalType, adapter) {
        this.__type = type;
        this.__typeName = typeName;
        this.__adapter = adapter;
        this.__optionalType = optionalType;
    }
    sql(sql, ...params) {
        return new ValueSourceImpl_1.FragmentValueSource(sql, params, this.__type, this.__typeName, this.__optionalType, this.__adapter);
    }
}
exports.FragmentQueryBuilder = FragmentQueryBuilder;
class FragmentFunctionBuilder {
    constructor(definitions) {
        this.definitions = definitions;
    }
    as(impl) {
        return (...args) => {
            const newArgs = [];
            for (let i = 0, length = args.length; i < length; i++) {
                const arg = args[i];
                if ((0, values_1.isValueSource)(arg)) {
                    newArgs.push(arg);
                }
                else {
                    const definition = this.definitions[i];
                    const newArg = new ValueSourceImpl_1.SqlOperationConstValueSource(arg, definition.type, definition.typeName, definition.optionalType, definition.adapter);
                    newArgs.push(newArg);
                }
            }
            return impl.apply(undefined, newArgs);
        };
    }
}
exports.FragmentFunctionBuilder = FragmentFunctionBuilder;
class FragmentFunctionBuilderIfValue {
    constructor(sqlBuilderSource, definitions) {
        this.sqlBuilderSource = sqlBuilderSource;
        this.definitions = definitions;
    }
    as(impl) {
        return (...args) => {
            const newArgs = [];
            for (let i = 0, length = args.length; i < length; i++) {
                const arg = args[i];
                if ((0, values_1.isValueSource)(arg)) {
                    newArgs.push(arg);
                }
                else {
                    const definition = this.definitions[i];
                    const optional = definition.optionalType !== 'required';
                    const valueMode = definition.mode === 'value';
                    if (optional && valueMode) {
                        if (!this.sqlBuilderSource.__sqlBuilder._isValue(arg)) {
                            return new ValueSourceImpl_1.SqlOperationValueSourceIfValueAlwaysNoop();
                        }
                    }
                    const newArg = new ValueSourceImpl_1.SqlOperationConstValueSource(arg, definition.type, definition.typeName, definition.optionalType, definition.adapter);
                    newArgs.push(newArg);
                }
            }
            return impl.apply(undefined, newArgs);
        };
    }
}
exports.FragmentFunctionBuilderIfValue = FragmentFunctionBuilderIfValue;
class FragmentFunctionBuilderMaybeOptional {
    constructor(sqlBuilderSource, definitions) {
        this.sqlBuilderSource = sqlBuilderSource;
        this.definitions = definitions;
    }
    as(impl) {
        return (...args) => {
            let optionalType = 'required';
            const newArgs = [];
            for (let i = 0, length = args.length; i < length; i++) {
                const arg = args[i];
                let argOptionalType;
                if ((0, values_1.isValueSource)(arg)) {
                    argOptionalType = (0, values_1.__getValueSourcePrivate)(arg).__optionalType;
                    newArgs.push(arg);
                }
                else {
                    if (this.sqlBuilderSource.__sqlBuilder._isValue(arg)) {
                        argOptionalType = 'required';
                    }
                    else {
                        argOptionalType = 'optional';
                    }
                    const definition = this.definitions[i];
                    const newArg = new ValueSourceImpl_1.SqlOperationConstValueSource(arg, definition.type, definition.typeName, definition.optionalType, definition.adapter);
                    newArgs.push(newArg);
                }
                optionalType = (0, values_1.__mergeOptional)(optionalType, argOptionalType);
            }
            const result = impl.apply(undefined, newArgs);
            (0, values_1.__getValueSourcePrivate)(result).__optionalType = optionalType;
            return result;
        };
    }
}
exports.FragmentFunctionBuilderMaybeOptional = FragmentFunctionBuilderMaybeOptional;
