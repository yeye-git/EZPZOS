import { AnyValueSource } from "../expressions/values";
import { QueryColumns, SqlBuilder } from "../sqlBuilders/SqlBuilder";
import { Column } from "../utils/Column";
import { ITableOrView, IWithView } from "../utils/ITableOrView";
interface Compose {
    type: 'compose';
    config: {
        externalProperty: string;
        internalProperty: string;
        propertyName: string;
    };
    deleteInternal: boolean;
    deleteExternal: boolean;
    cardinality?: 'noneOrOne' | 'one' | 'many' | 'optionalMany';
    fn?: (ids: any[]) => Promise<any[]>;
}
interface Split {
    type: 'split';
    optional: boolean;
    propertyName: string;
    mapping: {
        [key: string]: string;
    };
}
interface GuidedSplit {
    type: 'guidedSplit';
    optional: boolean;
    propertyName: string;
    mapping: {
        [key: string]: string;
    };
}
type SplitCompose = Compose | Split | GuidedSplit;
export declare class ComposeSplitQueryBuilder {
    __sqlBuilder: SqlBuilder;
    __compositions: SplitCompose[];
    __lastComposition?: Compose;
    __columns?: QueryColumns;
    __projectOptionalValuesAsNullable?: boolean;
    constructor(sqlBuilder: SqlBuilder);
    __isValue<T>(value: T): value is NonNullable<T>;
    compose(config: any): any;
    composeDeletingInternalProperty(config: any): any;
    composeDeletingExternalProperty(config: any): any;
    withNoneOrOne(fn: (ids: any[]) => Promise<any[]>): any;
    withOne(fn: (ids: any[]) => Promise<any[]>): any;
    withMany(fn: (ids: any[]) => Promise<any[]>): any;
    withOptionalMany(fn: (ids: any[]) => Promise<any[]>): any;
    splitRequired(propertyName: string, mappig: any): any;
    splitOptional(propertyName: string, mappig: any): any;
    split(propertyName: string, mappig: any): any;
    guidedSplitRequired(propertyName: string, mappig: any): any;
    guidedSplitOptional(propertyName: string, mappig: any): any;
    __applyCompositions<R>(result: Promise<R>, source: Error): Promise<R>;
    __applySplit<R>(dataResult: R, split: Split): R;
    __applyComposition<R>(dataResult: R, composition: Compose, source: Error): Promise<R> | R;
    __applyGuidedSplit<R>(dataResult: R, split: GuidedSplit): R;
    __processCompositionResult(internalList: any[], dataList: any[], dataMap: any, composition: Compose): void;
    __transformValueFromDB(valueSource: AnyValueSource, value: any, column?: string, index?: number, count?: boolean): {} | null | undefined;
    __transformRow(row: any, index?: number): any;
    __transformRootObject(projectOptionalValuesAsNullable: boolean, errorPrefix: string, columns: QueryColumns, row: any, index?: number): any;
    __transformAggregatedArray(projectOptionalValuesAsNullable: boolean, errorPrefix: string, valueSource: AnyValueSource, value: any, index?: number): any;
    __transformProjectedObject(projectOptionalValuesAsNullable: boolean, errorPrefix: string, pathPrefix: string, columns: QueryColumns, row: any, index?: number): any;
    __getOldValueOfColumns(columns: QueryColumns | undefined): ITableOrView<any> | undefined;
    __getValuesForInsertOfColumns(columns: {
        [property: string]: any;
    } | undefined): ITableOrView<any> | undefined;
    __registerTableOrViewOfColumns(columns: QueryColumns | undefined, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerTableOrViewWithOfColumns(columns: QueryColumns | undefined, withs: IWithView<any>[]): void;
    __registerRequiredColumnOfColmns(columns: QueryColumns | undefined, requiredColumns: Set<Column>, newOnly: Set<ITableOrView<any>>): void;
    __getColumnFromColumnsObject(prop: string | number | symbol): AnyValueSource | undefined;
    __getColumnNameFromColumnsObjectLowerCase(prop: string | number | symbol): string | undefined;
}
export declare function __setQueryMetadata(source: Error, params: any[], queryMetadata?: {
    queryExecutionName?: string;
    queryExecutionMetadata?: any;
} | undefined, isSelectPageCountQuery?: boolean): void;
export {};
