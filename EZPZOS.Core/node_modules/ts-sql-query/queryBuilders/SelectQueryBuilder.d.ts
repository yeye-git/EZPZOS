import { SqlBuilder, JoinData, ToSql, SelectData, CompoundOperator, CompoundSelectData, PlainSelectData, QueryColumns, OrderByEntry } from "../sqlBuilders/SqlBuilder";
import type { SelectExpression, SelectColumns, OrderByMode, SelectExpressionSubquery, ExecutableSelectExpressionWithoutWhere, DynamicWhereExecutableSelectExpression, GroupByOrderByExecutableSelectExpression, OffsetExecutableSelectExpression, DynamicWhereExpressionWithoutSelect, /*SelectExpressionFromNoTable,*/ SelectWhereJoinExpression, DynamicOnExpression, OnExpression, SelectExpressionWithoutJoin, SelectWhereExpression, OrderByExecutableSelectExpression, GroupByOrderByHavingExecutableSelectExpression, DynamicHavingExecutableSelectExpression, GroupByOrderHavingByExpressionWithoutSelect, DynamicHavingExpressionWithoutSelect, ICompoundableSelect, CompoundableCustomizableExecutableSelectExpression, CompoundedExecutableSelectExpression, ExecutableSelect, ComposeExpression, ComposeExpressionDeletingInternalProperty, ComposeExpressionDeletingExternalProperty, WithableExecutableSelect, SelectCustomization, WhereableExecutableSelectExpressionWithGroupBy, DynamicWhereExecutableSelectExpressionWithGroupBy, GroupByOrderByHavingExecutableSelectExpressionWithoutWhere, DynamicHavingExecutableSelectExpressionWithoutWhere, DynamicWhereSelectExpressionWithoutSelect, CompoundableExecutableSelectExpression, CompoundedOrderByExecutableSelectExpression, CompoundedOffsetExecutableSelectExpression, CompoundedCustomizableExecutableSelect, OrderableExecutableSelectExpressionWithoutWhere, OrderByExecutableSelectExpressionWithoutWhere, OffsetExecutableSelectExpressionWithoutWhere, CompoundableCustomizableExpressionWithoutWhere, DynamicWhereLimitExecutableSelectExpression, DynamicWhereCompoundableCustomizableExecutableSelectExpression, ExecutableSelectWithWhere, ExecutableSelectWithoutWhere, WithableExecutableSelectWithoutWhere, CompoundableExecutableSelectExpressionWithoutWhere, CompoundableCustomizableExecutableSelectExpressionWitoutWhere, SplitedComposedExecutableSelectWithoutWhere, SplitedComposedDynamicWhereExecutableSelectExpression, WhereableCompoundableExecutableSelectExpressionWithoutWhere, RecursivelyConnectedExecutableSelectExpression, RecursivelyConnectedExpressionWithoutSelect, RecursivelyConnectedExecutableSelectExpressionWithoutWhere, CompoundedLimitExecutableSelectExpression, CompoundedOrderedExecutableSelectExpression, LimitExecutableSelectExpression, OrderedExecutableSelectExpression, LimitExecutableSelectExpressionWithoutWhere, OrderedExecutableSelectExpressionWithoutWhere, RecursivelyConnectedSelectWhereExpression, ConnectByExpression, OrderByExecutableSelectExpressionProjectableAsNullable, GroupByOrderByExecutableSelectExpressionProjectableAsNullable, WhereableExecutableSelectExpressionWithGroupByProjectableAsNullable } from "../expressions/select";
import { HasAddWiths, HasIsValue, ITableOrView, IWithView, OuterJoinSource } from "../utils/ITableOrView";
import { IIfValueSource, IBooleanValueSource, INumberValueSource, IIntValueSource, IExecutableSelectQuery, AnyValueSource, AlwaysIfValueSource } from "../expressions/values";
import type { int } from "ts-extended-types";
import type { WithView } from "../utils/tableOrViewUtils";
import { AggregateFunctions0ValueSource } from "../internal/ValueSourceImpl";
import { columnsType, database, requiredTableOrView, resultType, type, compoundableColumns, isSelectQueryObject } from "../utils/symbols";
import { WithViewImpl } from "../internal/WithViewImpl";
import { ComposeSplitQueryBuilder } from "./ComposeSliptQueryBuilder";
import { Column } from "../utils/Column";
declare abstract class AbstractSelect extends ComposeSplitQueryBuilder implements ToSql, HasAddWiths, IExecutableSelectQuery<any, any, any, any>, CompoundableCustomizableExecutableSelectExpression<any, any, any, any, any, any>, CompoundedExecutableSelectExpression<any, any, any, any, any, any>, WithableExecutableSelect<any, any, any, any, any>, ExecutableSelect<any, any, any, any>, ComposeExpression<any, any, any, any, any, any, any>, ComposeExpressionDeletingInternalProperty<any, any, any, any, any, any, any>, ComposeExpressionDeletingExternalProperty<any, any, any, any, any, any, any>, LimitExecutableSelectExpression<any, any, any, any, any, any>, OrderByExecutableSelectExpression<any, any, any, any, any, any>, OrderedExecutableSelectExpression<any, any, any, any, any, any>, OffsetExecutableSelectExpression<any, any, any, any, any, any>, CompoundableCustomizableExecutableSelectExpression<any, any, any, any, any, any>, CompoundableExecutableSelectExpression<any, any, any, any, any, any>, CompoundedLimitExecutableSelectExpression<any, any, any, any, any>, CompoundedOrderByExecutableSelectExpression<any, any, any, any, any, any>, CompoundedOrderedExecutableSelectExpression<any, any, any, any, any, any>, CompoundedOffsetExecutableSelectExpression<any, any, any, any, any>, CompoundedCustomizableExecutableSelect<any, any, any, any, any>, OrderableExecutableSelectExpressionWithoutWhere<any, any, any, any, any, any>, ExecutableSelectWithWhere<any, any, any, any>, ExecutableSelectWithoutWhere<any, any, any, any, any>, WithableExecutableSelectWithoutWhere<any, any, any, any, any, any>, CompoundableExecutableSelectExpressionWithoutWhere<any, any, any, any, any, any>, CompoundableCustomizableExecutableSelectExpressionWitoutWhere<any, any, any, any, any, any> {
    [database]: any;
    [requiredTableOrView]: any;
    [type]: any;
    [compoundableColumns]: any;
    [resultType]: any;
    [columnsType]: any;
    [isSelectQueryObject]: true;
    __columns: QueryColumns;
    __orderBy?: OrderByEntry[];
    __orderingSiblingsOnly?: boolean;
    __limit?: int | number | INumberValueSource<any, any> | IIntValueSource<any, any>;
    __offset?: int | number | INumberValueSource<any, any> | IIntValueSource<any, any>;
    __withs: Array<IWithView<any>>;
    __customization?: SelectCustomization<any>;
    __oneColumn: boolean;
    __requiredResult?: boolean;
    __query: string;
    __params: any[];
    __recursiveInternalView?: WithViewImpl<any, any>;
    __recursiveView?: WithViewImpl<any, any>;
    __recursiveSelect?: SelectData & AbstractSelect;
    __subSelectUsing?: ITableOrView<any>[];
    __asInlineAggregatedArrayValue?: boolean;
    constructor(sqlBuilder: SqlBuilder);
    query(): string;
    params(): any[];
    executeSelectNoneOrOne(): Promise<any>;
    executeSelectOne(): Promise<any>;
    __executeSelectMany(source: Error): Promise<any>;
    executeSelectMany(): Promise<any>;
    abstract __buildSelectCount(countAll: AggregateFunctions0ValueSource, params: any[]): string;
    __executeSelectCount(source: Error): Promise<any>;
    executeSelectPage(extras?: any): Promise<any>;
    projectingOptionalValuesAsNullable(): any;
    abstract __finishJoinHaving(): void;
    orderBy(column: any, mode?: OrderByMode): any;
    __addOrderBy(column: any, mode?: OrderByMode): void;
    orderByFromString(orderBy: string): any;
    orderByFromStringIfValue(orderBy: string | null | undefined): any;
    orderingSiblingsOnly(): any;
    limit(limit: int | number | INumberValueSource<any, any> | IIntValueSource<any, any>): any;
    limitIfValue(limit: int | number | null | undefined): any;
    offset(offset: int | number | INumberValueSource<any, any> | IIntValueSource<any, any>): any;
    offsetIfValue(offset: int | number | null | undefined): any;
    __combineSubSelectUsing(select: ICompoundableSelect<any, any, any, any>, result: CompoundSelectQueryBuilder): void;
    union(select: ICompoundableSelect<any, any, any, any>): any;
    unionAll(select: ICompoundableSelect<any, any, any, any>): any;
    intersect(select: ICompoundableSelect<any, any, any, any>): any;
    intersectAll(select: ICompoundableSelect<any, any, any, any>): any;
    except(select: ICompoundableSelect<any, any, any, any>): any;
    exceptAll(select: ICompoundableSelect<any, any, any, any>): any;
    minus(select: ICompoundableSelect<any, any, any, any>): any;
    minusAll(select: ICompoundableSelect<any, any, any, any>): any;
    __compoundableAsSelectData(select: ICompoundableSelect<any, any, any, any>): SelectData;
    __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void;
    __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void;
    __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    abstract __registerRequiredColumnInSelect(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    abstract __isAllowed(sqlBuilder: HasIsValue): boolean;
    abstract __asSelectData(): SelectData & AbstractSelect;
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string;
    forUseInQueryAs(as: string): WithView<any, any>;
    forUseAsInlineQueryValue(): any;
    forUseAsInlineAggregatedArrayValue(): any;
    __buildRecursive(fn: (view: any) => ICompoundableSelect<any, any, any, any>, unionAll: boolean): void;
    recursiveUnion(fn: (view: any) => ICompoundableSelect<any, any, any, any>): any;
    recursiveUnionAll(fn: (view: any) => ICompoundableSelect<any, any, any, any>): any;
    __buildRecursiveFn(fn: (view: any) => IBooleanValueSource<any, any>): (view: any) => ICompoundableSelect<any, any, any, any>;
    recursiveUnionOn(fn: (view: any) => IBooleanValueSource<any, any>): any;
    recursiveUnionAllOn(fn: (view: any) => IBooleanValueSource<any, any>): any;
    customizeQuery(customization: SelectCustomization<any>): any;
}
export declare class SelectQueryBuilder extends AbstractSelect implements ToSql, PlainSelectData, SelectExpression<any, any, any, any>, /*SelectExpressionFromNoTable<any, any>,*/ ExecutableSelectExpressionWithoutWhere<any, any, any, any, any, any>, RecursivelyConnectedExecutableSelectExpressionWithoutWhere<any, any, any, any, any, any>, DynamicWhereExecutableSelectExpression<any, any, any, any, any, any>, DynamicWhereExpressionWithoutSelect<any, any, any, any>, RecursivelyConnectedExpressionWithoutSelect<any, any, any, any>, GroupByOrderByExecutableSelectExpression<any, any, any, any, any, any>, GroupByOrderByExecutableSelectExpressionProjectableAsNullable<any, any, any, any, any, any>, RecursivelyConnectedExecutableSelectExpression<any, any, any, any, any, any>, SelectWhereJoinExpression<any, any, any, any>, DynamicOnExpression<any, any, any, any>, OnExpression<any, any, any, any>, SelectExpressionWithoutJoin<any, any, any, any>, SelectExpressionSubquery<any, any, any>, SelectWhereExpression<any, any, any, any>, RecursivelyConnectedSelectWhereExpression<any, any, any, any>, GroupByOrderByHavingExecutableSelectExpression<any, any, any, any, any, any>, DynamicHavingExecutableSelectExpression<any, any, any, any, any, any>, GroupByOrderHavingByExpressionWithoutSelect<any, any, any, any>, DynamicHavingExpressionWithoutSelect<any, any, any, any>, WhereableExecutableSelectExpressionWithGroupBy<any, any, any, any, any, any>, WhereableExecutableSelectExpressionWithGroupByProjectableAsNullable<any, any, any, any, any, any>, DynamicWhereExecutableSelectExpressionWithGroupBy<any, any, any, any, any, any>, GroupByOrderByHavingExecutableSelectExpressionWithoutWhere<any, any, any, any, any, any>, DynamicHavingExecutableSelectExpressionWithoutWhere<any, any, any, any, any, any>, DynamicWhereSelectExpressionWithoutSelect<any, any, any, any>, LimitExecutableSelectExpressionWithoutWhere<any, any, any, any, any, any>, OrderByExecutableSelectExpressionWithoutWhere<any, any, any, any, any, any>, OrderedExecutableSelectExpressionWithoutWhere<any, any, any, any, any, any>, OffsetExecutableSelectExpressionWithoutWhere<any, any, any, any, any, any>, CompoundableCustomizableExpressionWithoutWhere<any, any, any, any, any, any>, DynamicWhereLimitExecutableSelectExpression<any, any, any, any, any, any>, DynamicWhereCompoundableCustomizableExecutableSelectExpression<any, any, any, any, any, any>, SplitedComposedExecutableSelectWithoutWhere<any, any, any, any, any>, SplitedComposedDynamicWhereExecutableSelectExpression<any, any, any, any, any>, WhereableCompoundableExecutableSelectExpressionWithoutWhere<any, any, any, any, any, any>, DynamicWhereCompoundableCustomizableExecutableSelectExpression<any, any, any, any, any, any>, ConnectByExpression<any, any, any>, OrderByExecutableSelectExpressionProjectableAsNullable<any, any, any, any, any, any> {
    __type: 'plain';
    __distinct: boolean;
    __tablesOrViews: Array<ITableOrView<any>>;
    __joins: Array<JoinData>;
    __where?: AlwaysIfValueSource<any, any>;
    __startWith?: AlwaysIfValueSource<any, any>;
    __connectBy?: AlwaysIfValueSource<any, any>;
    __connectByNoCycle?: boolean;
    __having?: AlwaysIfValueSource<any, any>;
    __groupBy: Array<AnyValueSource>;
    __requiredTablesOrViews?: Set<ITableOrView<any>>;
    __lastJoin?: JoinData;
    __inHaving: boolean;
    __hasOptionalJoin: boolean;
    constructor(sqlBuilder: SqlBuilder, tables: Array<ITableOrView<any>>, distinct: boolean);
    __registerRequiredColumnInSelect(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __buildSelectCount(countAll: AggregateFunctions0ValueSource, params: any[]): string;
    select(columns: SelectColumns<any, any>): any;
    selectOneColumn(column: AnyValueSource): any;
    selectCountAll(): any;
    from(table: ITableOrView<any>): any;
    join(table: ITableOrView<any>): any;
    innerJoin(table: ITableOrView<any>): any;
    leftJoin(source: OuterJoinSource<any, any>): any;
    leftOuterJoin(source: OuterJoinSource<any, any>): any;
    optionalJoin(table: ITableOrView<any>): any;
    optionalInnerJoin(table: ITableOrView<any>): any;
    optionalLeftJoin(source: OuterJoinSource<any, any>): any;
    optionalLeftOuterJoin(source: OuterJoinSource<any, any>): any;
    dynamicOn(): any;
    on(condition: IBooleanValueSource<any, any> | IIfValueSource<any, any>): any;
    __finishJoinHaving(): void;
    dynamicWhere(): any;
    where(condition: IBooleanValueSource<any, any> | IIfValueSource<any, any>): any;
    and(condition: IBooleanValueSource<any, any> | IIfValueSource<any, any>): any;
    or(condition: IBooleanValueSource<any, any> | IIfValueSource<any, any>): any;
    dynamicHaving(): any;
    having(condition: IBooleanValueSource<any, any> | IIfValueSource<any, any>): any;
    groupBy(...columns: Array<string | number | symbol | AnyValueSource>): any;
    startWith(condition: IBooleanValueSource<any, any> | IIfValueSource<any, any>): any;
    connectBy(condition: (prior: (column: AnyValueSource) => any) => IBooleanValueSource<any, any>): any;
    connectByNoCycle(condition: (prior: (column: AnyValueSource) => any) => IBooleanValueSource<any, any>): any;
    __asSelectData(): SelectData & AbstractSelect;
    __generateRequiredTableOrView(): Set<ITableOrView<any>>;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export declare class CompoundSelectQueryBuilder extends AbstractSelect implements ToSql, CompoundSelectData {
    __type: 'compound';
    __firstQuery: SelectData;
    __compoundOperator: CompoundOperator;
    __secondQuery: SelectData;
    constructor(sqlBuilder: SqlBuilder, firstQuery: SelectData, compoundOperator: CompoundOperator, secondQuery: SelectData);
    __registerRequiredColumnInSelect(sqlBuilder: HasIsValue, requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void;
    __buildSelectCount(countAll: AggregateFunctions0ValueSource, params: any[]): string;
    __finishJoinHaving(): void;
    __asSelectData(): SelectData & AbstractSelect;
    __getOldValues(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __getValuesForInsert(sqlBuilder: HasIsValue): ITableOrView<any> | undefined;
    __isAllowed(sqlBuilder: HasIsValue): boolean;
}
export {};
