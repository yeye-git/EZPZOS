"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TediousQueryRunner = void 0;
const tedious_1 = require("tedious");
const PromiseBasedQueryRunner_1 = require("./PromiseBasedQueryRunner");
/**
 * @deprecated Use mssql instead with MssqlPoolQueryRunner or MssqlPoolQueryRunner
 */
class TediousQueryRunner extends PromiseBasedQueryRunner_1.PromiseBasedQueryRunner {
    constructor(connection) {
        super();
        this.transactionLevel = 0;
        this.predefinedTypes = {
            boolean: tedious_1.TYPES.Bit,
            stringInt: tedious_1.TYPES.BigInt,
            int: tedious_1.TYPES.Int,
            bigint: tedious_1.TYPES.BigInt,
            stringDouble: tedious_1.TYPES.Float,
            double: tedious_1.TYPES.Real,
            string: tedious_1.TYPES.NVarChar,
            uuid: tedious_1.TYPES.UniqueIdentifier,
            localDate: tedious_1.TYPES.Date,
            localTime: tedious_1.TYPES.Time,
            localDateTime: tedious_1.TYPES.DateTime2,
            customInt: tedious_1.TYPES.BigInt,
            customDouble: tedious_1.TYPES.Float,
            customUuid: tedious_1.TYPES.UniqueIdentifier,
            customLocalDate: tedious_1.TYPES.Date,
            customLocalTime: tedious_1.TYPES.Time,
            customLocalDateTime: tedious_1.TYPES.DateTime2
        };
        this.connection = connection;
        this.database = 'sqlServer';
    }
    useDatabase(database) {
        if (database !== 'sqlServer') {
            throw new Error('Unsupported database: ' + database + '. TediousQueryRunner only supports sqlServer databases');
        }
    }
    getNativeRunner() {
        return this.connection;
    }
    getCurrentNativeTransaction() {
        return undefined;
    }
    execute(fn) {
        return fn(this.connection);
    }
    executeQueryReturning(query, params) {
        return new Promise((resolve, reject) => {
            let result = [];
            const req = new tedious_1.Request(query, (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            });
            for (var i = 0, length = params.length; i < length; i++) {
                req.addParameter('' + i, this.getType(params, i), params[i]);
            }
            req.on('row', function (columns) {
                const obj = {};
                for (var i = 0, length = columns.length; i < length; i++) {
                    const column = columns[i];
                    obj[column.metadata.colName] = column.value;
                }
                result.push(obj);
            });
            this.connection.execSql(req);
        });
    }
    executeMutation(query, params) {
        return new Promise((resolve, reject) => {
            const req = new tedious_1.Request(query, (error, rowCount) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(rowCount);
                }
            });
            for (var i = 0, length = params.length; i < length; i++) {
                req.addParameter('' + i, this.getType(params, i), params[i]);
            }
            this.connection.execSql(req);
        });
    }
    executeBeginTransaction() {
        return new Promise((resolve, reject) => {
            this.connection.beginTransaction((error) => {
                if (error) {
                    reject(error);
                }
                else {
                    this.transactionLevel++;
                    resolve();
                }
            });
        });
    }
    executeCommit() {
        return new Promise((resolve, reject) => {
            this.connection.commitTransaction((error) => {
                if (error) {
                    // Transaction count only modified when commit successful, in case of error there is still an open transaction 
                    reject(error);
                }
                else {
                    this.transactionLevel--;
                    if (this.transactionLevel < 0) {
                        this.transactionLevel = 0;
                    }
                    resolve();
                }
            });
        });
    }
    executeRollback() {
        return new Promise((resolve, reject) => {
            this.connection.rollbackTransaction((error) => {
                this.transactionLevel--;
                if (this.transactionLevel < 0) {
                    this.transactionLevel = 0;
                }
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    isTransactionActive() {
        return this.transactionLevel > 0;
    }
    addParam(params, value) {
        const index = params.length;
        params.push(value);
        return '@' + index;
    }
    getType(params, index) {
        const definedType = params['@' + index];
        if (definedType) {
            const type = this.predefinedTypes[definedType];
            if (type) {
                return type;
            }
        }
        return this.inferType(params[index]);
    }
    inferType(value) {
        // Inspired by: https://github.com/Hypermediaisobar-admin/node-any-db-mssql/blob/master/index.js
        if (value === null || value === undefined) {
            return tedious_1.TYPES.Null;
        }
        else if (typeof value === 'number') {
            if (Number.isSafeInteger(value)) {
                return tedious_1.TYPES.Int;
            }
            else {
                return tedious_1.TYPES.Real;
            }
        }
        else if (typeof value === 'bigint') {
            return tedious_1.TYPES.BigInt;
        }
        else if (typeof value === 'boolean') {
            return tedious_1.TYPES.Bit;
        }
        else if (value instanceof Array) {
            return (value.length > 0 ? this.inferType(value[0]) : tedious_1.TYPES.Null);
        }
        else if (value instanceof Date) {
            switch (value.___type___) {
                case 'LocalDateTime':
                    return tedious_1.TYPES.DateTime2;
                case 'LocalDate':
                    return tedious_1.TYPES.Date;
                case 'LocalTime':
                    return tedious_1.TYPES.Time;
                default:
                    return tedious_1.TYPES.DateTime2; // Maybe: TYPES.DateTimeOffset
            }
        }
        else if (typeof value === 'string') {
            if (/^-?\d+$/.test(value)) {
                if (value.length > 9) {
                    return tedious_1.TYPES.BigInt;
                }
                else {
                    return tedious_1.TYPES.Int;
                }
            }
            else if (/^-?\d+\.\d+$/.test(value)) {
                return tedious_1.TYPES.Real;
            }
            else if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
                return tedious_1.TYPES.Date;
            }
            else if (/^\d{2}\:\d{2}(?:\:\d{2})?(?:\+\d{4})?$/.test(value)) {
                return tedious_1.TYPES.Time;
            }
            else if (/^\d{4}-\d{2}-\d{2}\s+\d{2}\:\d{2}(?:\:\d{2}(?:\.\d+)?)?$/.test(value)) {
                return tedious_1.TYPES.DateTime2;
            }
            else if (/^\d{4}-\d{2}-\d{2}T\d{2}\:\d{2}\:\d{2}(?:\.\d+)?$/.test(value)) {
                return tedious_1.TYPES.DateTime2;
            }
            else if (/^\d{4}-\d{2}-\d{2}\s+\d{2}\:\d{2}(?:\:\d{2}(?:\.\d+)?)?(?:[\+\-]\d{2}\:\d{2}|Z)?$/.test(value)) {
                return tedious_1.TYPES.DateTimeOffset;
            }
            else if (/^\d{4}-\d{2}-\d{2}T\d{2}\:\d{2}\:\d{2}(?:\.\d+)?(?:[\+\-]\d{2}\:\d{2}|Z)?$/.test(value)) {
                return tedious_1.TYPES.DateTimeOffset;
            }
            else if (/^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i.test(value)) {
                return tedious_1.TYPES.UniqueIdentifier;
            }
            else {
                return tedious_1.TYPES.NVarChar;
            }
        }
        return tedious_1.TYPES.VarBinary;
    }
}
exports.TediousQueryRunner = TediousQueryRunner;
