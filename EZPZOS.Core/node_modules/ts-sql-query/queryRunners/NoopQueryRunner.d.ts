import type { PromiseProvider, UnwrapPromiseTuple } from "../utils/PromiseProvider";
import type { DatabaseType, QueryRunner } from "./QueryRunner";
export interface NoopQueryRunnerConfig {
    database?: DatabaseType;
    promise?: PromiseProvider;
}
export declare class NoopQueryRunner implements QueryRunner {
    readonly database: DatabaseType;
    readonly promise: PromiseProvider;
    private transactionLevel;
    constructor(databaseOrConfig?: DatabaseType | NoopQueryRunnerConfig);
    useDatabase(database: DatabaseType): void;
    getNativeRunner(): unknown;
    getCurrentNativeTransaction(): unknown;
    execute<RESULT>(fn: (connection: unknown, transaction?: unknown) => Promise<RESULT>): Promise<RESULT>;
    executeSelectOneRow(_query: string, _params?: any[]): Promise<any>;
    executeSelectManyRows(_query: string, _params?: any[]): Promise<any[]>;
    executeSelectOneColumnOneRow(_query: string, _params?: any[]): Promise<any>;
    executeSelectOneColumnManyRows(_query: string, _params?: any[]): Promise<any[]>;
    executeInsert(_query: string, _params?: any[]): Promise<number>;
    executeInsertReturningLastInsertedId(_query: string, _params?: any[]): Promise<any>;
    executeInsertReturningMultipleLastInsertedId(_query: string, _params?: any[]): Promise<any>;
    executeInsertReturningOneRow(_query: string, _params?: any[]): Promise<any>;
    executeInsertReturningManyRows(_query: string, _params?: any[]): Promise<any[]>;
    executeInsertReturningOneColumnOneRow(_query: string, _params?: any[]): Promise<any>;
    executeInsertReturningOneColumnManyRows(_query: string, _params?: any[]): Promise<any[]>;
    executeUpdate(_query: string, _params?: any[]): Promise<number>;
    executeUpdateReturningOneRow(_query: string, _params?: any[]): Promise<any>;
    executeUpdateReturningManyRows(_query: string, _params?: any[]): Promise<any[]>;
    executeUpdateReturningOneColumnOneRow(_query: string, _params?: any[]): Promise<any>;
    executeUpdateReturningOneColumnManyRows(_query: string, _params?: any[]): Promise<any[]>;
    executeDelete(_query: string, _params?: any[]): Promise<number>;
    executeDeleteReturningOneRow(_query: string, _params?: any[]): Promise<any>;
    executeDeleteReturningManyRows(_query: string, _params?: any[]): Promise<any[]>;
    executeDeleteReturningOneColumnOneRow(_query: string, _params?: any[]): Promise<any>;
    executeDeleteReturningOneColumnManyRows(_query: string, _params?: any[]): Promise<any[]>;
    executeProcedure(_query: string, _params?: any[]): Promise<void>;
    executeFunction(_query: string, _params?: any[]): Promise<any>;
    executeBeginTransaction(): Promise<void>;
    executeCommit(): Promise<void>;
    executeRollback(): Promise<void>;
    isTransactionActive(): boolean;
    executeDatabaseSchemaModification(_query: string, _params?: any[]): Promise<void>;
    executeConnectionConfiguration(_query: string, _params?: any[]): Promise<void>;
    addParam(params: any[], value: any): string;
    addOutParam(params: any[], name: string): string;
    executeInTransaction<P extends Promise<any>[]>(fn: () => [...P], outermostQueryRunner: QueryRunner): Promise<UnwrapPromiseTuple<P>>;
    executeInTransaction<T>(fn: () => Promise<T>, outermostQueryRunner: QueryRunner): Promise<T>;
    executeInTransaction(fn: () => Promise<any>[] | Promise<any>, outermostQueryRunner: QueryRunner): Promise<any>;
    executeCombined<R1, R2>(fn1: () => Promise<R1>, fn2: () => Promise<R2>): Promise<[R1, R2]>;
    createResolvedPromise<RESULT>(result: RESULT): Promise<RESULT>;
    createAllPromise<P extends Promise<any>[]>(promises: [...P]): Promise<UnwrapPromiseTuple<P>>;
    isMocked(): boolean;
    lowLevelTransactionManagementSupported(): boolean;
}
