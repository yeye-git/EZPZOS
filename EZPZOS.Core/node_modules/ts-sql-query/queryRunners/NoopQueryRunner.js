"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoopQueryRunner = void 0;
class NoopQueryRunner {
    constructor(databaseOrConfig = 'noopDB') {
        this.transactionLevel = 0;
        if (typeof databaseOrConfig === 'string') {
            databaseOrConfig = { database: databaseOrConfig };
        }
        this.database = databaseOrConfig.database || 'noopDB';
        this.promise = databaseOrConfig.promise || Promise;
    }
    useDatabase(database) {
        // @ts-ignore
        this.database = database;
    }
    getNativeRunner() {
        return null;
    }
    getCurrentNativeTransaction() {
        return undefined;
    }
    execute(fn) {
        return fn(null);
    }
    executeSelectOneRow(_query, _params = []) {
        return this.promise.resolve(undefined);
    }
    executeSelectManyRows(_query, _params = []) {
        return this.promise.resolve([]);
    }
    executeSelectOneColumnOneRow(_query, _params = []) {
        return this.promise.resolve(undefined);
    }
    executeSelectOneColumnManyRows(_query, _params = []) {
        return this.promise.resolve([]);
    }
    executeInsert(_query, _params = []) {
        return this.promise.resolve(0);
    }
    executeInsertReturningLastInsertedId(_query, _params = []) {
        return this.promise.resolve(undefined);
    }
    executeInsertReturningMultipleLastInsertedId(_query, _params = []) {
        return this.promise.resolve([]);
    }
    executeInsertReturningOneRow(_query, _params = []) {
        return this.promise.resolve(undefined);
    }
    executeInsertReturningManyRows(_query, _params = []) {
        return this.promise.resolve([]);
    }
    executeInsertReturningOneColumnOneRow(_query, _params = []) {
        return this.promise.resolve(undefined);
    }
    executeInsertReturningOneColumnManyRows(_query, _params = []) {
        return this.promise.resolve([]);
    }
    executeUpdate(_query, _params = []) {
        return this.promise.resolve(0);
    }
    executeUpdateReturningOneRow(_query, _params = []) {
        return this.promise.resolve(undefined);
    }
    executeUpdateReturningManyRows(_query, _params = []) {
        return this.promise.resolve([]);
    }
    executeUpdateReturningOneColumnOneRow(_query, _params = []) {
        return this.promise.resolve(undefined);
    }
    executeUpdateReturningOneColumnManyRows(_query, _params = []) {
        return this.promise.resolve([]);
    }
    executeDelete(_query, _params = []) {
        return this.promise.resolve(0);
    }
    executeDeleteReturningOneRow(_query, _params = []) {
        return this.promise.resolve(undefined);
    }
    executeDeleteReturningManyRows(_query, _params = []) {
        return this.promise.resolve([]);
    }
    executeDeleteReturningOneColumnOneRow(_query, _params = []) {
        return this.promise.resolve(undefined);
    }
    executeDeleteReturningOneColumnManyRows(_query, _params = []) {
        return this.promise.resolve([]);
    }
    executeProcedure(_query, _params = []) {
        return this.promise.resolve();
    }
    executeFunction(_query, _params = []) {
        return this.promise.resolve(undefined);
    }
    executeBeginTransaction() {
        this.transactionLevel++;
        return this.promise.resolve();
    }
    executeCommit() {
        this.transactionLevel--;
        return this.promise.resolve();
    }
    executeRollback() {
        this.transactionLevel--;
        return this.promise.resolve();
    }
    isTransactionActive() {
        return this.transactionLevel > 0;
    }
    executeDatabaseSchemaModification(_query, _params = []) {
        return this.promise.resolve();
    }
    executeConnectionConfiguration(_query, _params = []) {
        return this.promise.resolve();
    }
    addParam(params, value) {
        const index = params.length;
        let result;
        switch (this.database) {
            case 'mariaDB':
                result = '?';
                break;
            case 'mySql':
                result = '?';
                break;
            case 'noopDB':
                result = '$' + index;
                break;
            case 'oracle':
                result = ':' + index;
                break;
            case 'postgreSql':
                result = '$' + (index + 1);
                break;
            case 'sqlite':
                result = '?';
                break;
            case 'sqlServer':
                result = '@' + index;
                break;
            default:
                throw new Error('Unknown database ' + this.database);
        }
        params.push(value);
        return result;
    }
    addOutParam(params, name) {
        const index = params.length;
        params.push({ out_param_with_name: name });
        return ':' + index;
    }
    executeInTransaction(fn, outermostQueryRunner) {
        return outermostQueryRunner.executeBeginTransaction().then(() => {
            let result = fn();
            if (Array.isArray(result)) {
                result = this.createAllPromise(result);
            }
            return result.then((r) => {
                return outermostQueryRunner.executeCommit().then(() => {
                    return r;
                });
            }, (e) => {
                return outermostQueryRunner.executeRollback().then(() => {
                    throw e;
                }, () => {
                    // Throw the innermost error
                    throw e;
                });
            });
        });
    }
    executeCombined(fn1, fn2) {
        return fn1().then((r1) => {
            return fn2().then((r2) => {
                return [r1, r2];
            });
        });
    }
    createResolvedPromise(result) {
        return this.promise.resolve(result);
    }
    createAllPromise(promises) {
        return this.promise.all(promises);
    }
    isMocked() {
        return false;
    }
    lowLevelTransactionManagementSupported() {
        return true;
    }
}
exports.NoopQueryRunner = NoopQueryRunner;
