import { UnwrapPromiseTuple } from "../utils/PromiseProvider";
import { AbstractQueryRunner } from "./AbstractQueryRunner";
import { DatabaseType, QueryRunner } from "./QueryRunner";
interface RawPrismaClient2 {
    $executeRaw<_T = any>(query: string, ...values: any[]): Promise<number>;
    $queryRaw<T = any>(query: string, ...values: any[]): Promise<T>;
    $transaction(arg: any, options?: any): Promise<any>;
}
interface RawPrismaClient3 {
    $executeRawUnsafe<_T = any>(query: string, ...values: any[]): Promise<number>;
    $queryRawUnsafe<T = any>(query: string, ...values: any[]): Promise<T>;
    $transaction(arg: any, options?: any): Promise<any>;
}
type RawPrismaClient = RawPrismaClient2 | RawPrismaClient3;
export interface PrismaConfig {
    interactiveTransactions: boolean;
    interactiveTransactionsOptions?: {
        maxWait?: number;
        timeout?: number;
        isolationLevel?: string;
    };
    forUseInTransaction?: boolean;
}
export declare class PrismaQueryRunner extends AbstractQueryRunner {
    readonly database: DatabaseType;
    readonly connection: RawPrismaClient;
    readonly transaction?: RawPrismaClient;
    readonly config: PrismaConfig;
    private transactionLevel;
    constructor(connection: RawPrismaClient, config?: PrismaConfig);
    useDatabase(database: DatabaseType): void;
    getNativeRunner(): RawPrismaClient;
    getCurrentNativeTransaction(): RawPrismaClient | undefined;
    execute<RESULT>(fn: (connection: unknown, transaction?: unknown) => Promise<RESULT>): Promise<RESULT>;
    protected executeQueryReturning(query: string, params: any[]): Promise<any[]>;
    protected executeMutation(query: string, params: any[]): Promise<number>;
    executeInsertReturningLastInsertedId(query: string, params?: any[]): Promise<any>;
    executeBeginTransaction(): Promise<void>;
    executeCommit(): Promise<void>;
    executeRollback(): Promise<void>;
    isTransactionActive(): boolean;
    executeInTransaction<P extends Promise<any>[]>(fn: () => [...P], outermostQueryRunner: QueryRunner): Promise<UnwrapPromiseTuple<P>>;
    executeInTransaction<T>(fn: () => Promise<T>, outermostQueryRunner: QueryRunner): Promise<T>;
    executeInTransaction(fn: () => Promise<any>[] | Promise<any>, outermostQueryRunner: QueryRunner): Promise<any>;
    addParam(params: any[], value: any): string;
    createResolvedPromise<RESULT>(result: RESULT): Promise<RESULT>;
    executeCombined<R1, R2>(fn1: () => Promise<R1>, fn2: () => Promise<R2>): Promise<[R1, R2]>;
    lowLevelTransactionManagementSupported(): boolean;
    protected wrapPrismaPromise(promise: Promise<any>): Promise<any>;
}
export {};
