"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsNodeSqlV8QueryRunner = void 0;
const PromiseBasedQueryRunner_1 = require("./PromiseBasedQueryRunner");
/**
 * @deprecated Use mssql instead with MssqlPoolQueryRunner or MssqlPoolQueryRunner
 */
class MsNodeSqlV8QueryRunner extends PromiseBasedQueryRunner_1.PromiseBasedQueryRunner {
    constructor(connection) {
        super();
        this.transactionLevel = 0;
        this.connection = connection;
        this.database = 'sqlServer';
    }
    useDatabase(database) {
        if (database !== 'sqlServer') {
            throw new Error('Unsupported database: ' + database + '. MsNodeSqlV8QueryRunner only supports sqlServer databases');
        }
    }
    getNativeRunner() {
        return this.connection;
    }
    getCurrentNativeTransaction() {
        return undefined;
    }
    execute(fn) {
        return fn(this.connection);
    }
    executeQueryReturning(query, params) {
        return new Promise((resolve, reject) => {
            this.connection.query(query, params, function (error, rows) {
                if (error) {
                    reject(error);
                }
                else if (!rows) {
                    resolve([]);
                }
                else {
                    resolve(rows);
                }
            });
        });
    }
    executeMutation(query, params) {
        return new Promise((resolve, reject) => {
            let rowCount = 0;
            this.connection.query(query, params, function (error) {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(rowCount);
                }
            }).on('rowcount', function (count) {
                rowCount = count;
            });
        });
    }
    executeBeginTransaction() {
        return new Promise((resolve, reject) => {
            this.connection.beginTransaction((error) => {
                if (error) {
                    reject(error);
                }
                else {
                    this.transactionLevel++;
                    resolve();
                }
            });
        });
    }
    executeCommit() {
        return new Promise((resolve, reject) => {
            this.connection.commit((error) => {
                if (error) {
                    // Transaction count only modified when commit successful, in case of error there is still an open transaction 
                    reject(error);
                }
                else {
                    this.transactionLevel--;
                    if (this.transactionLevel < 0) {
                        this.transactionLevel = 0;
                    }
                    resolve();
                }
            });
        });
    }
    executeRollback() {
        return new Promise((resolve, reject) => {
            this.connection.rollback((error) => {
                this.transactionLevel--;
                if (this.transactionLevel < 0) {
                    this.transactionLevel = 0;
                }
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    isTransactionActive() {
        return this.transactionLevel > 0;
    }
    addParam(params, value) {
        const index = params.length;
        params.push(value);
        return '@' + index;
    }
}
exports.MsNodeSqlV8QueryRunner = MsNodeSqlV8QueryRunner;
